---
title: LeetCode
date: 2023-11-16 17:26:39
permalink: /pages/4dde8d/
---
# LeetCode 刷题

## 栈

### 42. 接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![42](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/42.jpg)

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        Stack<Integer> st = new Stack<>();
        for (int i = 0; i < height.length; i ++) {
            int last = 0;
            while (!st.isEmpty() && height[st.peek()] <= height[i]) {
                ans += (i - st.peek() - 1) * (height[st.peek()] - last);
                last = height[st.pop()];
            }
            if (!st.isEmpty()) {
                ans += (i - st.peek() - 1) * (height[i] - last);
            }
            st.push(i);
        }
        return ans;
    }
}
```

### 365. 水壶问题

有两个水壶，容量分别为 `jug1Capacity` 和 `jug2Capacity` 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 `targetCapacity` 升。

如果可以得到 `targetCapacity` 升水，最后请用以上水壶中的一或两个来盛放取得的 `targetCapacity` 升水。

你可以：

- 装满任意一个水壶
- 清空任意一个水壶
- 从一个水壶向另外一个水壶倒水，直到装满或者倒空

![365](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/365.jpg)

```java
class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
        Deque<int[]> stk = new LinkedList<int[]>();
        stk.push(new int[]{0, 0});
        Set<Long> seen = new HashSet<>();
        while (!stk.isEmpty()) {
            if (seen.contains(hash(stk.peek()))) {
                stk.pop();
                continue;
            }
            seen.add(hash(stk.peek()));

            int[] state = stk.pop();
            int rx = state[0], ry = state[1];
            if (rx == z || ry == z || rx + ry == z) {
                return true;
            }
            // 把 X 壶灌满。
            stk.push(new int[]{x, ry});
            // 把 Y 壶灌满。
            stk.push(new int[]{rx, y});
            // 把 X 壶倒空。
            stk.push(new int[]{0, ry});
            // 把 Y 壶倒空。
            stk.push(new int[]{rx, 0});
            // 把 X 壶的水灌进 Y 壶，直至灌满或倒空。
            stk.push(new int[]{rx - Math.min(rx, y - ry), ry + Math.min(rx, y - ry)});
            // 把 Y 壶的水灌进 X 壶，直至灌满或倒空。
            stk.push(new int[]{rx + Math.min(ry, x - rx), ry - Math.min(ry, x - rx)});
        }
        return false;
    }

    long hash(int[] state) {
        return (long) state[0] * 1000001 + state[1];
    }
}
```

### 394. 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

![394. 字符串解码](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/394.jpg)

```java
class Solution {
    public String decodeString(String s) {
        StringBuilder result = new StringBuilder();
        Stack<Integer> countStack = new Stack<>();
        Stack<StringBuilder> strStack = new Stack<>();
        int index = 0;

        while (index < s.length()) {
            char c = s.charAt(index);

            if (Character.isDigit(c)) {
                // 获取重复次数
                int count = 0;
                while (Character.isDigit(s.charAt(index))) {
                    count = count * 10 + (s.charAt(index) - '0');
                    index++;
                }
                countStack.push(count);
            } else if (c == '[') {
                // 将结果和重复次数入栈
                strStack.push(result);
                result = new StringBuilder();
                index++;
            } else if (c == ']') {
                // 出栈计算结果
                StringBuilder temp = strStack.pop();
                int repeatTimes = countStack.pop();
                for (int i = 0; i < repeatTimes; i++) {
                    temp.append(result);
                }
                result = temp;
                index++;
            } else {
                // 字符串部分直接添加到结果中
                result.append(c);
                index++;
            }
        }

        return result.toString();
    }
}
```

### 901. 股票价格跨度

设计一个算法收集某些股票的每日报价，并返回该股票当日价格的 **跨度** 。

当日股票价格的 **跨度** 被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

- 例如，如果未来 7 天股票的价格是 `[100,80,60,70,60,75,85]`，那么股票跨度将是 `[1,1,1,2,1,4,6]` 。

实现 `StockSpanner` 类：

- `StockSpanner()` 初始化类对象。
- `int next(int price)` 给出今天的股价 `price` ，返回该股票当日价格的 **跨度** 。

![901](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/901.jpg)

```java
class StockSpanner {
    Stack<int[]> stk;
    int top = -1;
    public StockSpanner() {
        stk = new Stack<int[]>();
        stk.push(new int[]{-1, Integer.MAX_VALUE / 2});
    }

    public int next(int price) {
        top ++;
        while (price >= stk.peek()[1]) {
            stk.pop();
        }
        int res = top - stk.peek()[0];
        stk.push(new int[]{top, price});
        return res;
    }
}

/**
 * Your StockSpanner object will be instantiated and called as such:
 * StockSpanner obj = new StockSpanner();
 * int param_1 = obj.next(price);
 */
```

### 907. 子数组的最小值之和

给定一个整数数组 `arr`，找到 `min(b)` 的总和，其中 `b` 的范围为 `arr` 的每个（连续）子数组。

由于答案可能很大，因此 **返回答案模 `10^9 + 7` 。

![907](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/907.jpg)

```java
class Solution {
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        int[] l = new int[n], r = new int[n];
        Stack<Integer> stk = new Stack<>();
        for (int i = 0; i < n; i ++) {
            while (!stk.isEmpty() && arr[stk.peek()] > arr[i]) stk.pop();
            if (stk.isEmpty()) l[i] = -1;
            else l[i] = stk.peek();
            stk.push(i);
        }
        stk = new Stack<>();
        for (int i = n - 1; i >= 0; i --) {
            while (!stk.isEmpty() && arr[stk.peek()] >= arr[i]) stk.pop();
            if (stk.isEmpty()) r[i] = n;
            else r[i] = stk.peek();
            stk.push(i);
        }
        final int mod = (int)1e9 + 7;
        long res = 0L;
        for (int i = 0; i < n; i ++) {
            res = (res + (long)arr[i] * (i - l[i]) * (r[i] - i)) % mod;
        }
        return (int)res;
    }
}
```

### 2454. 下一个更大元素 IV

给你一个下标从 **0** 开始的非负整数数组 `nums` 。对于 `nums` 中每一个整数，你必须找到对应元素的 **第二大** 整数。

如果 `nums[j]` 满足以下条件，那么我们称它为 `nums[i]` 的 **第二大** 整数：

- `j > i`
- `nums[j] > nums[i]`
- 恰好存在 **一个** `k` 满足 `i < k < j` 且 `nums[k] > nums[i]` 。

如果不存在 `nums[j]` ，那么第二大整数为 `-1` 。

- 比方说，数组 `[1, 2, 4, 3]` 中，`1` 的第二大整数是 `4` ，`2` 的第二大整数是 `3` ，`3` 和 `4` 的第二大整数是 `-1` 。

请你返回一个整数数组 `answer` ，其中 `answer[i]`是 `nums[i]` 的第二大整数。

![2454](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2454.jpg)

**思路**
![思路](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2454_1.jpg)

```java
class Solution {
    public int[] secondGreaterElement(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        List<Integer> t = new ArrayList<>();
        List<Integer> s = new ArrayList<>();
        for (int i = 0; i < n; i ++) {
            while (!t.isEmpty() && nums[t.get(t.size() - 1)] < nums[i]) {
                ans[t.get(t.size() - 1)] = nums[i];
                t.remove(t.size() - 1);
            }
            int j = s.size();
            while (j > 0 && nums[s.get(j - 1)] < nums[i]) {
                j --;
            }
            List<Integer> popped = s.subList(j, s.size());
            t.addAll(popped); // 把从 s 弹出的这一整段元素加到 t
            popped.clear(); // 弹出一整段元素
            s.add(i); // 当前元素（的下标）加到 s 栈顶
        }
        return ans;
    }
}
```

### 2865. 美丽塔 I

给你一个长度为 `n` 下标从 **0** 开始的整数数组 `maxHeights` 。

你的任务是在坐标轴上建 `n` 座塔。第 `i` 座塔的下标为 `i` ，高度为 `heights[i]` 。

如果以下条件满足，我们称这些塔是 **美丽** 的：

1. `1 <= heights[i] <= maxHeights[i]`
2. `heights` 是一个 **山脉** 数组。

如果存在下标 `i` 满足以下条件，那么我们称数组 `heights` 是一个 **山脉** 数组：

- 对于所有 `0 < j <= i` ，都有 `heights[j - 1] <= heights[j]`
- 对于所有 `i <= k < n - 1` ，都有 `heights[k + 1] <= heights[k]`

请你返回满足 **美丽塔** 要求的方案中**，高度和的最大值** 。

![2865](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2865.jpg)

```java
class Solution {
    // 枚举
    // public long maximumSumOfHeights(List<Integer> maxHeights) {
    //     int n = maxHeights.size();
    //     long res = 0L;
    //     for (int i = 0; i < n; i ++) {
    //         int pre = maxHeights.get(i);
    //         long sum = pre;
    //         for (int j = i - 1; j >= 0; j --) {
    //             pre = Math.min(pre, maxHeights.get(j));
    //             sum += pre;
    //         }
    //         int suf = maxHeights.get(i);
    //         for (int j = i + 1; j < n; j ++) {
    //             suf = Math.min(suf, maxHeights.get(j));
    //             sum += suf;
    //         }
    //         res = Math.max(res, sum);
    //     }
    //     return res;
    // }
    // 单调栈
    public long maximumSumOfHeights(List<Integer> maxHeights) {
        int n = maxHeights.size();
        long res = 0L;
        long[] prefix = new long[n], suffix = new long[n];
        Deque<Integer> stk1 = new ArrayDeque<>(), stk2 = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            while (!stk1.isEmpty() && maxHeights.get(i) < maxHeights.get(stk1.peek())) {
                stk1.pop();
            }
            if (stk1.isEmpty()) {
                prefix[i] = (long) (i + 1) * maxHeights.get(i);
            } else {
                prefix[i] = prefix[stk1.peek()] + (long) (i - stk1.peek()) * maxHeights.get(i);
            }
            stk1.push(i);
        }
        for (int i = n - 1; i >= 0; i--) {
            while (!stk2.isEmpty() && maxHeights.get(i) < maxHeights.get(stk2.peek())) {
                stk2.pop();
            }
            if (stk2.isEmpty()) {
                suffix[i] = (long) (n - i) * maxHeights.get(i);
            } else {
                suffix[i] = suffix[stk2.peek()] + (long) (stk2.peek() - i) * maxHeights.get(i);
            }
            stk2.push(i);
            res = Math.max(res, prefix[i] + suffix[i] - maxHeights.get(i));
        }
        return res;
    }
}
```

## 队列

**双端队列**

`Deque`是一个双端队列接口，继承自`Queue`接口，`Deque`的实现类是`LinkedList、ArrayDeque、LinkedBlockingDeque`，其中`LinkedList`是最常用的。

Deque 有三种用途：

```java
// 普通队列(一端进另一端出):
Queue queue = new LinkedList();
// 或者
Deque deque = new LinkedList();
// 双端队列(两端都可进出)
Deque deque = new LinkedList();
// 堆栈
Deque deque = new LinkedList();
```

| 操作          | 描述                                              |
| ------------- | ------------------------------------------------- |
| addFirst(e)   | 在队列的头部插入元素 e                            |
| offerFirst(e) | 在队列的头部插入元素 e，如果队列已满则返回 false  |
| addLast(e)    | 在队列的尾部插入元素 e                            |
| offerLast(e)  | 在队列的尾部插入元素 e，如果队列已满则返回 false  |
| removeFirst() | 移除并返回队列头部的元素，如果队列为空则抛出异常  |
| pollFirst()   | 移除并返回队列头部的元素，如果队列为空则返回 null |
| removeLast()  | 移除并返回队列尾部的元素，如果队列为空则抛出异常  |
| pollLast()    | 移除并返回队列尾部的元素，如果队列为空则返回 null |
| getFirst()    | 返回队列头部的元素，但不移除                      |
| peekFirst()   | 返回队列头部的元素，但不移除                      |
| getLast()     | 返回队列尾部的元素，但不移除                      |
| peekLast()    | 返回队列尾部的元素，但不移除                      |

Deque 接口扩展(继承)了 Queue 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：

| Queue 方法 | 等效 Deque 方法 |
| ---------- | --------------- |
| add(e)     | addLast(e)      |
| offer(e)   | offerLast(e)    |
| remove()   | removeFirst()   |
| poll()     | pollFirst()     |
| element()  | getFirst()      |
| peek()     | peekFirst()     |

双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示：

| 堆栈方法 | 等效 Deque 方法 |
| -------- | --------------- |
| push(e)  | addFirst(e)     |
| pop()    | removeFirst()   |
| peek()   | peekFirst()     |

### 1670. 设计前中后队列

请你设计一个队列，支持在前，中，后三个位置的 `push` 和 `pop` 操作。

请你完成 `FrontMiddleBack` 类：

- `FrontMiddleBack()` 初始化队列。
- `void pushFront(int val)` 将 `val` 添加到队列的 **最前面** 。
- `void pushMiddle(int val)` 将 `val` 添加到队列的 **正中间** 。
- `void pushBack(int val)` 将 `val` 添加到队里的 **最后面** 。
- `int popFront()` 将 **最前面** 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 `-1` 。
- `int popMiddle()` 将 **正中间** 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 `-1` 。
- `int popBack()` 将 **最后面** 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 `-1` 。

请注意当有 **两个** 中间位置的时候，选择靠前面的位置进行操作。比方说：

- 将 `6` 添加到 `[1, 2, 3, 4, 5]` 的中间位置，结果数组为 `[1, 2, **6**, 3, 4, 5]` 。
- 从 `[1, 2, **3**, 4, 5, 6]` 的中间位置弹出元素，返回 `3` ，数组变为 `[1, 2, 4, 5, 6]` 。

![1670](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1670.jpg)

```java
class FrontMiddleBackQueue {
    Deque<Integer> left = new ArrayDeque<>();
    Deque<Integer> right = new ArrayDeque<>();

    void balance() {
        if (left.size() > right.size()) {
            right.addFirst(left.pollLast());
        } else if (right.size() > left.size() + 1) {
            left.addLast(right.pollFirst());
        }
    }
    public FrontMiddleBackQueue() {

    }

    public void pushFront(int val) {
        left.addFirst(val);
        balance();
    }

    public void pushMiddle(int val) {
        if (left.size() < right.size()) {
            left.addLast(val);
        } else {
            right.addFirst(val);
        }
    }

    public void pushBack(int val) {
        right.addLast(val);
        balance();
    }

    public int popFront() {
        if (right.isEmpty()) {
            return -1;
        }
        int val = left.isEmpty() ? right.pollFirst() : left.pollFirst();
        balance();
        return val;
    }

    public int popMiddle() {
        if (right.isEmpty()) {
            return -1;
        }
        if (left.size() == right.size()) {
            return left.pollLast();
        }
        return right.pollFirst();
    }

    public int popBack() {
        if (right.isEmpty()) {
            return -1;
        }
        int val = right.pollLast();
        balance();
        return val;
    }
}

/**
 * Your FrontMiddleBackQueue object will be instantiated and called as such:
 * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();
 * obj.pushFront(val);
 * obj.pushMiddle(val);
 * obj.pushBack(val);
 * int param_4 = obj.popFront();
 * int param_5 = obj.popMiddle();
 * int param_6 = obj.popBack();
 */
```

## 滑动窗口

### 1423. 可获得的最大点数

几张卡牌 **排成一行**，每张卡牌都有一个对应的点数。点数由整数数组 `cardPoints` 给出。

每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 `k` 张卡牌。

你的点数就是你拿到手中的所有卡牌的点数之和。

给你一个整数数组 `cardPoints` 和整数 `k`，请你返回可以获得的最大点数。

**思路**

记数组 `cardPoints` 的长度为 `n`，由于只能从开头和末尾拿 `k` 张卡牌，所以最后剩下的必然是连续的 `n−k` 张卡牌。

我们可以通过求出剩余卡牌点数之和的最小值，来求出拿走卡牌点数之和的最大值。

![1423](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1423.jpg)

```java
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        int n = cardPoints.length;
        int ws = n - k;
        int sum = 0;
        for (int i = 0; i < ws; i ++) {
            sum += cardPoints[i];
        }
        int minSum = sum;
        for (int i = ws; i < n; i ++) {
            sum += cardPoints[i] - cardPoints[i - ws];
            minSum = Math.min(minSum, sum);
        }
        return Arrays.stream(cardPoints).sum() - minSum;
    }
}
```

## 模拟

### 1041. 困于环中的机器人

在无限的平面上，机器人最初位于 `(0, 0)` 处，面朝北方。注意:

- **北方向** 是 y 轴的正方向。
- **南方向** 是 y 轴的负方向。
- **东方向** 是 x 轴的正方向。
- **西方向** 是 x 轴的负方向。

机器人可以接受下列三条指令之一：

- `"G"`：直走 1 个单位
- `"L"`：左转 90 度
- `"R"`：右转 90 度

机器人按顺序执行指令 `instructions`，并一直重复它们。

只有在平面中存在环使得机器人永远无法离开时，返回 `true`。否则，返回 `false`。

![1041](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1041.jpg)

```java
class Solution {
    public boolean isRobotBounded(String instructions) {
        int[][] dir = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};
        int[] cur = {0, 0};
        int k = 0;
        for (char c : instructions.toCharArray()) {
            if (c == 'G') {
                cur[0] += dir[k][0];
                cur[1] += dir[k][1];
            } else if (c == 'L') {
                k = (k + 1) % 4;
            } else {
                k = (-- k + 4) % 4;
            }
        }
        return k != 0 || (cur[0] == 0 && cur[1] == 0);
    }
}
```

### 1222. 可以攻击国王的皇后

在一个 `8x8` 的棋盘上，放置着若干「黑皇后」和一个「白国王」。

给定一个由整数坐标组成的数组 queens ，表示黑皇后的位置；以及一对坐标 king ，表示白国王的位置，返回所有可以攻击国王的皇后的坐标(任意顺序)。

![1222. 可以攻击国王的皇后](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1222.jpg)

```java
class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        List<List<Integer>> res = new ArrayList<>();
        boolean[][] st = new boolean[8][8];
        for (int[] q : queens) {
            st[q[0]][q[1]] = true;
        }
        for (int i = -1; i <= 1; i ++) {
            for (int j = -1; j <= 1; j ++) {
                if (i != 0 || j != 0) {
                    int x = king[0], y = king[1];
                    while (true) {
                        x += i; y += j;
                        if (x < 0 || x >= 8 || y < 0 || y >= 8) {
                            break;
                        }
                        if (st[x][y]) {
                            res.add(Arrays.asList(new Integer[]{x, y}));
                            break;
                        }
                    }
                }
            }
        }
        return res;
    }
}
```

### 2596. 检查骑士巡视方案

骑士在一张 n x n 的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的 **左上角** 出发，并且访问棋盘上的每个格子 恰好一次 。

给你一个 n x n 的整数矩阵 grid ，由范围 `[0, n * n - 1] `内的不同整数组成，其中 `grid[row][col]` 表示单元格 (row, col) 是骑士访问的第 `grid[row][col]` 个单元格。骑士的行动是从下标 0 开始的。

如果 grid 表示了骑士的有效巡视方案，返回 true；否则返回 false。

注意，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。

![2596. 检查骑士巡视方案](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2596.jpg)

```java
class Solution {
    // 时间复杂度 O(n^2) 空间复杂度 O(n^2)
    public boolean checkValidGrid(int[][] grid) {
        if (grid[0][0] != 0) {
            return false;
        }
        int n = grid.length;
        int[][] indices = new int[n * n][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                indices[grid[i][j]][0] = i;
                indices[grid[i][j]][1] = j;
            }
        }
        for (int i = 1; i < n * n; i++) {
            int dx = Math.abs(indices[i][0] - indices[i - 1][0]);
            int dy = Math.abs(indices[i][1] - indices[i - 1][1]);
            if (dx * dy != 2) {
                return false;
            }
        }
        return true;
    }
}
```

**递归解法**

```java
class Solution {
    int n;
    boolean ans;
    int[] dx = new int[]{2, 2, -2, -2, 1, 1, -1, -1}, dy = new int[]{1, -1, 1, -1, 2, -2, 2, -2};

    public boolean checkValidGrid(int[][] grid) {
        if (grid[0][0] != 0) {
            return false;
        }
        n = grid.length;
        int originX = 0, originY = 0;
        dfs(originX, originY, 0, grid);
        return ans;
    }
    void dfs(int i, int j, int u, int[][] grid) {
        if (u == n * n - 1) {
            ans = grid[i][j] == u;
            return;
        }
        for (int k = 0; k < 8; k ++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < n && y >= 0 && y < n && grid[x][y] == u + 1) {
                dfs(x, y, u + 1, grid);
            }
        }
    }
}
```

## 计数

### 1010. 总持续时间可被 60 整除的歌曲

在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。

返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望下标数字 i 和 j 满足 i < j 且有 `(time[i] + time[j]) % 60 == 0`。

![总持续时间可被 60 整除的歌曲](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1010.jpg)

```java
class Solution {
    public int numPairsDivisibleBy60(int[] time) {
    int[] cnt = new int[60];
        for (int t : time) {
            cnt[t % 60] ++;
        }
        long res = 0;
        for (int i = 1; i < 30; i ++) {
            res += cnt[i] * cnt[60 - i];
        }
        res += (long)cnt[0] * (cnt[0] - 1) / 2 + (long)cnt[30] * (cnt[30] - 1) / 2;
        return (int)res;
    }
}
```

### 1267. 统计参与通信的服务器

这里有一幅服务器分布图，服务器的位置标识在 m \* n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。

如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。

请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。

![1267. 统计参与通信的服务器](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1267.jpg)

```java
class Solution {
    public int countServers(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        Map<Integer, Integer> rows = new HashMap<>();
        Map<Integer, Integer> cols = new HashMap<>();
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (grid[i][j] == 1) {
                    rows.put(i, rows.getOrDefault(i, 0) + 1);
                    cols.put(j, cols.getOrDefault(j, 0) + 1);
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (grid[i][j] == 1 && (rows.get(i) > 1 || cols.get(j) > 1)) {
                    ans ++;
                }
            }
        }
        return ans;
    }
}
```

### 1419. 数青蛙

给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 "croak" ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 croakOfFrogs 中会混合多个 “croak” 。

请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。

要想发出蛙鸣 "croak"，青蛙必须 依序 输出 ‘c’, ’r’, ’o’, ’a’, ’k’ 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。如果字符串 croakOfFrogs 不是由若干有效的 "croak" 字符混合而成，请返回 -1 。

![数青蛙](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1419.jpg)

```java
class Solution {
    public int minNumberOfFrogs(String croakOfFrogs) {
        int n = croakOfFrogs.length();
        Map<Character, Integer> map = new HashMap<Character, Integer>(){{
            put('c', 0);
            put('r', 1);
            put('o', 2);
            put('a', 3);
            put('k', 4);
        }};
        int ans = 0, frog_num = 0;
        int[] cnt = new int[4];
        for (int i = 0; i < n; i ++) {
            char c = croakOfFrogs.charAt(i);
            int t = map.get(c);
            if (t == 0) {
                frog_num ++;
                cnt[t] ++;
                ans = Math.max(ans, frog_num);
            } else {
                if (cnt[t - 1] == 0) {
                    return -1;
                }
                cnt[t - 1] --;
                if (t == 4) {
                    frog_num --;
                } else {
                    cnt[t] ++;
                }
            }
        }
        if (frog_num > 0) {
            return -1;
        }
        return ans;
    }
}
```

### 1657. 确定两个字符串是否接近

如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 **接近** ：

- 操作 1：交换任意两个现有字符。
  - 例如，`a**b**cd**e** -> a**e**cd**b`
- 操作 2：将一个现有字符的每次出现转换为另一个 现有字符，并对另一个字符执行相同的操作。
  - 例如，`aa**c**abb** -> **bb**c**baa`（所有 `a` 转化为 `b` ，而所有的 `b` 转换为 `a` ）

你可以根据需要对任意一个字符串多次使用这两种操作。

给你两个字符串，`word1` 和 `word2` 。如果 `word1` 和 `word2` **接近** ，就返回 `true` ；否则，返回 `false` 。

![1657](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1657.jpg)

```java
class Solution {
    public boolean closeStrings(String word1, String word2) {
        int[] hash1 = new int[26];
        int[] hash2 = new int[26];
        for (int i = 0; i < word1.length(); i ++) {
            hash1[word1.charAt(i) - 'a'] ++;
        }
        for (int i = 0; i < word2.length(); i ++) {
            hash2[word2.charAt(i) - 'a'] ++;
        }
        for (int i = 0; i < 26; i ++) {
            int a = hash1[i], b = hash2[i];
            if (a == 0 && b != 0 || a != 0 && b == 0) {
                return false;
            }
        }
        Arrays.sort(hash1);
        Arrays.sort(hash2);
        return Arrays.equals(hash1, hash2);
    }
}
```

## 哈希

### 299. 猜数字游戏

你在和朋友一起玩 [猜数字（Bulls and Cows）](https://baike.baidu.com/item/猜数字/83200?fromtitle=Bulls+and+Cows&fromid=12003488&fr=aladdin)游戏，该游戏规则如下：

写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：

- 猜测数字中有多少位属于数字和确切位置都猜对了（称为 "Bulls"，公牛），
- 有多少位属于数字猜对了但是位置不对（称为 "Cows"，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。

给你一个秘密数字 `secret` 和朋友猜测的数字 `guess` ，请你返回对朋友这次猜测的提示。

提示的格式为 `"xAyB"` ，`x` 是公牛个数， `y` 是奶牛个数，`A` 表示公牛，`B` 表示奶牛。

请注意秘密数字和朋友猜测的数字都可能含有重复数字。

![299](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/299.jpg)

```java
class Solution {
    public String getHint(String secret, String guess) {
        int bulls = 0;
        int[] hs = new int[10], hg = new int[10];
        for (int i = 0; i < secret.length(); i ++) {
            char s = secret.charAt(i), g = guess.charAt(i);
            if (s == g) {
                bulls ++;
            } else {
                hs[s - '0'] ++;
                hg[g - '0'] ++;
            }
        }
        int cows = 0;
        for (int i = 0; i < 10; i ++) {
            cows += Math.min(hs[i], hg[i]);
        }
        return bulls + "A" + cows + "B";
    }
}
```

### 447. 回旋镖的数量

给定平面上 `n` 对 **互不相同** 的点 `points` ，其中 `points[i] = [xi, yi]` **。回旋镖** 是由点 `(i, j, k)` 表示的元组 ，其中 `i` 和 `j` 之间的距离和 `i` 和 `k` 之间的欧式距离相等（**需要考虑元组的顺序**）。

返回平面上所有回旋镖的数量。

![447](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/447.jpg)

```java
class Solution {
    public int numberOfBoomerangs(int[][] points) {
        int res = 0;
        for (int[] p : points) {
            Map<Integer, Integer> hash = new HashMap<>();
            for (int[] q : points) {
                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);
                hash.put(dis, hash.getOrDefault(dis, 0) + 1);
            }
            for (Map.Entry<Integer, Integer> entry : hash.entrySet()) {
                int m = entry.getValue();
                res += m * (m - 1);
            }
        }
        return res;
    }
}
```

### 828. 统计子串中的唯一字符

我们定义了一个函数 `countUniqueChars(s)` 来统计字符串 `s` 中的唯一字符，并返回唯一字符的个数。

例如：`s = "LEETCODE"` ，则其中 `"L"`, `"T"`,`"C"`,`"O"`,`"D"` 都是唯一字符，因为它们只出现一次，所以 `countUniqueChars(s) = 5` 。

本题将会给你一个字符串 `s` ，我们需要返回 `countUniqueChars(t)` 的总和，其中 `t` 是 `s` 的子字符串。输入用例保证返回值为 32 位整数。

注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 `s` 的所有子字符串中的唯一字符）。

![828](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/828.jpg)

```java
class Solution {
    public int uniqueLetterString(String s) {
        Map<Character, List<Integer>> index = new HashMap<Character, List<Integer>>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (!index.containsKey(c)) {
                index.put(c, new ArrayList<Integer>());
                index.get(c).add(-1);
            }
            index.get(c).add(i);
        }
        int res = 0;
        for (Map.Entry<Character, List<Integer>> entry : index.entrySet()) {
            List<Integer> arr = entry.getValue();
            arr.add(s.length());
            for (int i = 1; i < arr.size() - 1; i++) {
                res += (arr.get(i) - arr.get(i - 1)) * (arr.get(i + 1) - arr.get(i));
            }
        }
        return res;
    }
}

```

### 874. 模拟行走机器人

机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：

- -2 ：向左转 90 度
- -1 ：向右转 90 度
- 1 <= x <= 9 ：向前移动 x 个单位长度

在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点 obstacles[i] = (xi, yi) 。

机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。

返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）

注意：

- 北表示 +Y 方向。
- 东表示 +X 方向。
- 南表示 -Y 方向。
- 西表示 -X 方向。

![模拟行走机器人](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/874.jpg)

```java
class Solution {
    public int robotSim(int[] commands, int[][] obstacles) {
        Set<String> set = new HashSet<>();
        int x = 0, y = 0, d = 0;
        int[] dx = new int[]{0, 1, 0, -1}, dy = new int[]{1, 0, -1, 0};
        int res = 0;
        for (int[] p : obstacles) {
            set.add(p[0] + "#" + p[1]);
        }
        for (int c : commands) {
            if (c == -2) {
                d = (d + 3) % 4;
            } else if (c == -1) {
                d = (d + 1) % 4;
            } else {
                for (int i = 0; i < c; i ++) {
                    int a = x + dx[d], b = y + dy[d];
                    if (set.contains(a + "#" + b)) {
                        break;
                    }
                    x = a; y = b;
                    res = Math.max(res, x * x + y * y);
                }
            }
        }
        return res;
    }
}
```

### 1726. 同积元组

给你一个由 **不同** 正整数组成的数组 `nums` ，请你返回满足 `a * b = c * d` 的元组 `(a, b, c, d)` 的数量。其中 `a`、`b`、`c` 和 `d` 都是 `nums` 中的元素，且 `a != b != c != d` 。

![1726](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1726.jpg)

**思路与算法**：统计数组中所有不同元素的乘积组合数目，然后计算在相同乘积的**数对**可以构成**同积元组**的数目，并求和即可得到最终的结果。

```java
class Solution {
    public int tupleSameProduct(int[] nums) {
        int n = nums.length;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i ++) {
            for (int j = i + 1; j < nums.length; j ++) {
                int x = nums[i] * nums[j];
                map.put(x, map.getOrDefault(x, 0) + 1);
            }
        }
        int res = 0;
        for (int x : map.values()) {
            res += x * (x - 1) * 4;
        }
        return res;
    }
}
```

### 2336. 无限集中的最小数字

现有一个包含所有正整数的集合 `[1, 2, 3, 4, 5, ...]` 。

实现 `SmallestInfiniteSet` 类：

- `SmallestInfiniteSet()` 初始化 **SmallestInfiniteSet** 对象以包含 **所有** 正整数。
- `int popSmallest()` **移除** 并返回该无限集中的最小整数。
- `void addBack(int num)` 如果正整数 `num` **不** 存在于无限集中，则将一个 `num` **添加** 到该无限集中。

![2336](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2336.jpg)

```java
class SmallestInfiniteSet {
    int idx;
    PriorityQueue<Integer> pq;
    public SmallestInfiniteSet() {
        idx = 1;
        pq = new PriorityQueue<>();
    }
    
    public int popSmallest() {
        if (pq.isEmpty()) {
            return idx ++;
        }
        return pq.poll();
    }
    
    public void addBack(int num) {
        if (num < idx && !pq.contains(num)) {
            pq.offer(num);
        }
    }
}

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet obj = new SmallestInfiniteSet();
 * int param_1 = obj.popSmallest();
 * obj.addBack(num);
 */
```

### 2342. 数位和相等数对的最大和

给你一个下标从 **0** 开始的数组 `nums` ，数组中的元素都是 **正** 整数。请你选出两个下标 `i` 和 `j`（`i != j`），且 `nums[i]` 的数位和 与 `nums[j]` 的数位和相等。

请你找出所有满足条件的下标 `i` 和 `j` ，找出并返回 `nums[i] + nums[j]` 可以得到的 **最大值** _。_

![2342](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2342.jpg)

```java
class Solution {
    public int maximumSum(int[] nums) {
        int ans = -1;
        int[] mx = new int[82];
        for (int x : nums) {
            int s = 0, t = x;
            while (t > 0) {
                s += t % 10;
                t /= 10;
            }
            if (mx[s] > 0) {
                ans = Math.max(ans, mx[s] + x);
            }
            mx[s] = Math.max(mx[s], x);
        }
        return ans;
    }
}
```

### 2441. 与对应负数同时存在的最大正整数

给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k 。

返回正整数 k ，如果不存在这样的整数，返回 -1 。

![与对应负数同时存在的最大正整数](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2441.jpg)

> `[-9,-43,24,-23,-16,-30,-38,-30]`
>
> `-1`

```java
class Solution {
    public int findMaxK(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < nums.length; i ++ ) {
            set.add(nums[i]);
        }
        int res = -1;
        for (int i = 0; i < nums.length; i ++) {
            if (set.contains(-nums[i])) {
                res = Math.max(Math.abs(nums[i]), res);
            }
        }
        return res;
    }
}
```

### 2661. 找出叠涂元素

给你一个下标从 **0** 开始的整数数组 `arr` 和一个 `m x n` 的整数 **矩阵** `mat` 。`arr` 和 `mat` 都包含范围 `[1，m * n]` 内的 **所有** 整数。

从下标 `0` 开始遍历 `arr` 中的每个下标 `i` ，并将包含整数 `arr[i]` 的 `mat` 单元格涂色。

请你找出 `arr` 中在 `mat` 的某一行或某一列上都被涂色且下标最小的元素，并返回其下标 `i` 。
 
![2661](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2661.jpg)

```java
class Solution {
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        Map<Integer, int[]> map = new HashMap<>();
        int n = mat.length, m = mat[0].length;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                map.put(mat[i][j], new int[]{i, j});
            }
        }
        int[] row = new int[n], col = new int[m];
        for (int i = 0; i < arr.length; i ++) {
            int[] cur = map.get(arr[i]);
            row[cur[0]] ++;
            if (row[cur[0]] == m) {
                return i;
            }
            col[cur[1]] ++;
            if (col[cur[1]] == n) {
                return i;
            }
        }
        return -1;
    }
}
```

### 2670. 找出不同元素数目差数组

给你一个下标从 **0** 开始的数组 `nums` ，数组长度为 `n` 。

`nums` 的 **不同元素数目差** 数组可以用一个长度为 `n` 的数组 `diff` 表示，其中 `diff[i]` 等于前缀 `nums[0, ..., i]` 中不同元素的数目 **减去** 后缀 `nums[i + 1, ..., n - 1]` 中不同元素的数目。

返回 `nums` 的 **不同元素数目差** 数组。

注意 `nums[i, ..., j]` 表示 `nums` 的一个从下标 `i` 开始到下标 `j` 结束的子数组（包含下标 `i` 和 `j` 对应元素）。特别需要说明的是，如果 `i > j` ，则 `nums[i, ..., j]` 表示一个空子数组。

![2670](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2670.jpg)

```java
class Solution {
    public int[] distinctDifferenceArray(int[] nums) {
        int n = nums.length;
        int[] diff = new int[n], suffix = new int[n + 1];
        Set<Integer> set = new HashSet<>();
        for (int i = n - 1; i > 0; i --) {
            set.add(nums[i]);
            suffix[i] = set.size();
        }
        set.clear();
        for (int i = 0; i < n; i ++) {
            set.add(nums[i]);
            diff[i] = set.size() - suffix[i + 1];
        }
        return diff;
    }
}
```

### 2671. 频率跟踪器

请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。

实现 `FrequencyTracker` 类：

- `FrequencyTracker()`：使用一个空数组初始化 `FrequencyTracker` 对象。
- `void add(int number)`：添加一个 `number` 到数据结构中。
- `void deleteOne(int number)`：从数据结构中删除一个 `number` 。数据结构 **可能不包含** `number` ，在这种情况下不删除任何内容。
- `bool hasFrequency(int frequency)`: 如果数据结构中存在出现 `frequency` 次的数字，则返回 `true`，否则返回 `false`。

![2671](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2671.jpg)

```java
class FrequencyTracker {
    Map<Integer, Integer> map;
    Map<Integer, Integer> fre;
    public FrequencyTracker() {
        map = new HashMap<>();
        fre = new HashMap<>();
    }
    
    public void add(int number) {
        int f = map.getOrDefault(number, 0);
        map.put(number, f + 1);
        fre.put(f, fre.getOrDefault(f, 0) - 1);
        fre.put(f + 1, fre.getOrDefault(f + 1, 0) + 1);
    }
    
    public void deleteOne(int number) {
        int f = map.getOrDefault(number, 0);
        if (f - 1 < 0) {
            return;
        }
        map.put(number, f - 1);
        fre.put(f, fre.getOrDefault(f, 0) - 1);
        fre.put(f - 1, fre.getOrDefault(f - 1, 0) + 1);
    }
    
    public boolean hasFrequency(int frequency) {
        return fre.getOrDefault(frequency, 0) > 0;
    }
}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * FrequencyTracker obj = new FrequencyTracker();
 * obj.add(number);
 * obj.deleteOne(number);
 * boolean param_3 = obj.hasFrequency(frequency);
 */
```

### 100258. 最高频率的 ID

你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 `n` 的整数数组 `nums` 和 `freq` ，`nums` 中每一个元素表示一个 ID ，对应的 `freq` 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。

- **增加 ID 的数目**：如果 `freq[i]` 是正数，那么 `freq[i]` 个 ID 为 `nums[i]` 的元素在第 `i` 步操作后会添加到集合中。
- **减少 ID 的数目**：如果 `freq[i]` 是负数，那么 `-freq[i]` 个 ID 为 `nums[i]` 的元素在第 `i` 步操作后会从集合中删除。

请你返回一个长度为 `n` 的数组 `ans` ，其中 `ans[i]` 表示第 `i` 步操作后出现频率最高的 ID **数目** ，如果在某次操作后集合为空，那么 `ans[i]` 为 0 。

![100258](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/100258.jpg)

```java
class Solution {
    public long[] mostFrequentIDs(int[] nums, int[] freq) {
        Map<Integer, Long> cnt = new HashMap<>();
        TreeMap<Long, Integer> m = new TreeMap<>();
        int n = nums.length;
        long[] ans = new long[n];
        for (int i = 0; i < n; i++) {
            int x = nums[i];
            if (cnt.containsKey(x) && m.containsKey(cnt.get(x)) && m.merge(cnt.get(x), -1, Integer::sum) == 0) { // --m[cnt[x]] == 0
                m.remove(cnt.get(x));
            }
            long c = cnt.merge(x, (long) freq[i], Long::sum); // cnt[x] += freq[i]
            m.merge(c, 1, Integer::sum); // ++m[cnt[x]]
            ans[i] = m.lastKey();
        }
        return ans;
    }
}
```

`Map.merge()` 的使用**

它将新的值赋值到 key （如果不存在）或更新给定的key 值对应的 value

```java
 Map<String, Integer> studentScoreMap2 = new HashMap<>();
        studentScoreList.forEach(studentScore -> studentScoreMap2.merge(
          studentScore.getStuName(),
          studentScore.getScore(),
          Integer::sum));

        System.out.println(objectMapper.writeValueAsString(studentScoreMap2));

// 汇总成绩结果如下：
// {"李四":228,"张三":215,"王五":235}

// merge() 源码部分
   default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        Objects.requireNonNull(value);
        V oldValue = this.get(key);
        V newValue = oldValue == null ? value : remappingFunction.apply(oldValue, value);
        if (newValue == null) {
            this.remove(key);
        } else {
            this.put(key, newValue);
        }

        return newValue;
    }
```

## 矩阵

### 1072. 按列翻转得到最大值等行数

给定 m x n 矩阵 matrix 。

你可以从中选出任意数量的列并翻转其上的 每个 单元格。（即翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。）

返回 经过一些翻转后，行与行之间所有值都相等的最大行数 。

![按列翻转得到最大值等行数](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1072.png)

```java
class Solution {
    public int maxEqualRowsAfterFlips(int[][] matrix) {
        int n = matrix.length, m = matrix[0].length, res = 1;
        Map<String, Integer> map = new HashMap<>();
        for (int i = 0; i < n; i ++) {
            StringBuilder a = new StringBuilder(""), b = new StringBuilder("");
            for (int x : matrix[i]) {
                a.append(x);
                b.append(x ^ 1);
            }
            map.put(a.toString(), map.getOrDefault(a.toString(), 0) + 1);
            map.put(b.toString(), map.getOrDefault(b.toString(), 0) + 1);
            res = Math.max(res, Math.max(map.get(a.toString()), map.get(b.toString())));
        }

        return res;
    }
}
```

### 2679. 矩阵中的和

给你一个下标从 0 开始的二维整数数组 nums 。一开始你的分数为 0 。你需要执行以下操作直到矩阵变为空：

矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。
在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 分数 中。
请你返回最后的 分数 。

![2679. 矩阵中的和](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2679.jpg)

**枚举**

```java
class Solution {
    public int matrixSum(int[][] nums) {
        int res = 0;
        int m = nums.length;
        int n = nums[0].length;
        for (int i = 0; i < m; i++) {
            Arrays.sort(nums[i]);
        }
        for (int j = 0; j < n; j++) {
            int maxVal = 0;
            for (int i = 0; i < m; i++) {
                maxVal = Math.max(maxVal, nums[i][j]);
            }
            res += maxVal;
        }
        return res;
    }
}
```

**使用优先队列**

```java
class Solution {
    public int matrixSum(int[][] nums) {
        int res = 0;
        int m = nums.length;
        int n = nums[0].length;
        PriorityQueue<Integer>[] pq = new PriorityQueue[m];
        for (int i = 0; i < m; i++) {
            pq[i] = new PriorityQueue<Integer>((a, b) -> b - a);
            for (int j = 0; j < n; j++) {
                pq[i].offer(nums[i][j]);
            }
        }
        for (int j = 0; j < n; j++) {
            int maxVal = 0;
            for (int i = 0; i < m; i++) {
                maxVal = Math.max(maxVal, pq[i].poll());
            }
            res += maxVal;
        }
        return res;
    }
}
```

## 贪心

### LCP 30. 魔塔游戏

小扣当前位于魔塔游戏第一层，共有 `N` 个房间，编号为 `0 ~ N-1`。每个房间的补血道具/怪物对于血量影响记于数组 `nums`，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；`0` 表示房间对血量无影响。

**小扣初始血量为 1，且无上限**。假定小扣原计划按房间编号升序访问所有房间补血/打怪**，为保证血量始终为正值**，小扣需对房间访问顺序进行调整**，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾**。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。

![LCP 30](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/lcp30.jpg)

```java
class Solution {
    public int magicTower(int[] nums) {
        long sum = 0;
        for (int x : nums) {
            sum += x;
        }
        if (sum < 0) {
            return -1;
        }
        int ans = 0;
        long cur = 1;
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int x : nums) {
            cur += x;
            if (x < 0) {
                minHeap.offer(x);
            }
            if (cur < 1) {
                cur -= minHeap.poll();
                ans ++;
            }
        }
        return ans;
    }
}
```

### 630. 课程表 III

这里有 n 门不同的在线课程，按从 1 到 n 编号。给你一个数组 courses ，其中 `courses[i] = [durationi, lastDayi]` 表示第 i 门课将会 持续 上 durationi 天课，并且必须在不晚于 lastDayi 的时候完成。

你的学期从第 1 天开始。且不能同时修读两门及两门以上的课程。

返回你最多可以修读的课程数目。

![630. 课程表 III](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/630.jpg)

```java
class Solution {
    /**
     * f(i) 考虑前i 个任务的所有合法方案：
     * 1. 选的课程个数最多
     * 2. 总用时最少（每种方案用时相同）
     * 加入第i 个任务后：
     *      方案合法： f(i) = f(i-1) + 1
     *      方案不合法： 删除一个最长任务 f(i) = f(i-1)
     */
    public int scheduleCourse(int[][] courses) {
        Arrays.sort(courses, (i1, i2) -> i1[1] - i2[1]);
        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> b - a);
        int tot = 0;
        for (int[] c : courses) {
            tot += c[0];
            heap.offer(c[0]);
            if (tot > c[1]) {
                tot -= heap.poll();
            }
        }
        return heap.size();
    }
}
```

### 670. 最大交换

给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。

![670](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/670.jpg)

```java
class Solution {
    public int maximumSwap(int num) {
        char[] cs = String.valueOf(num).toCharArray();
        int n = cs.length;
        int maxIdx = n - 1;
        int idx1 = -1, idx2 = -1;
        for (int i = n - 1; i >= 0; i --) {
            if (cs[i] > cs[maxIdx]) {
                maxIdx = i;
            } else if (cs[i] < cs[maxIdx]) {
                idx1 = i;
                idx2 = maxIdx;
            }
        }
        if (idx1 >= 0) {
            char temp = cs[idx1];
            cs[idx1] = cs[idx2];
            cs[idx2] = temp;
            return Integer.parseInt(new String(cs));
        } else {
            return num;
        }
    }
}
```

### 826. 安排工作以达到最大收益

你有 n 个工作和 m 个工人。给定三个数组： difficulty, profit 和 worker ，其中:

- difficulty[i] 表示第 i 个工作的难度，profit[i] 表示第 i 个工作的收益。
- worker[i] 是第 i 个工人的能力，即该工人只能完成难度小于等于 worker[i] 的工作。
每个工人 最多 只能安排 一个 工作，但是一个工作可以 完成多次 。

- 举个例子，如果 3 个工人都尝试完成一份报酬为 $1 的同样工作，那么总收益为 $3 。如果一个工人不能完成任何工作，他的收益为 $0 。
返回 在把工人分配到工作岗位后，我们所能获得的最大利润 。

![826](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1715926291388.jpg)

```java
class Solution {
    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
        int n = difficulty.length;
        int[][] jobs = new int[n][2];
        for (int i = 0; i < n; i ++) {
            jobs[i][0] = difficulty[i];
            jobs[i][1] = profit[i];
        }
        Arrays.sort(jobs, (a, b) -> a[0] - b[0]);
        Arrays.sort(worker);
        int ans = 0, j = 0, maxP = 0;
        for (int w : worker) {
            while (j < n && jobs[j][0] <= w) {
                maxP = Math.max(maxP, jobs[j ++][1]);
            }
            ans += maxP;
        }
        return ans;
    }
}
```

### 1054. 距离相等的条形码

在一个仓库里，有一排条形码，其中第 i 个条形码为 `barcodes[i]`。

请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。

![距离相等的条形码](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1054.jpg)

```java
class Solution {
    public int[] rearrangeBarcodes(int[] barcodes) {
        int n = barcodes.length;
        if (n < 2) {
            return barcodes;
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int x : barcodes) {
            map.put(x, map.getOrDefault(x, 0) + 1);
        }
        int evenIdx = 0, oddIdx = 1, half_n = n / 2;
        int[] res = new int[n];
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            int k = entry.getKey(), v = entry.getValue();
            while (v > 0 && v <= half_n && oddIdx < n) {
                v --;
                res[oddIdx] = k;
                oddIdx += 2;
            }
            while (v > 0) {
                v --;
                res[evenIdx] = k;
                evenIdx += 2;
            }
        }
        return res;
    }
}
```

### 1402. 做菜顺序

一个厨师收集了他 `n` 道菜的满意程度 `satisfaction` ，这个厨师做出每道菜的时间都是 1 单位时间。

一道菜的 「 **like-time 系数** 」定义为烹饪这道菜结束的时间（包含之前每道菜所花费的时间）乘以这道菜的满意程度，也就是 `time[i]`\*`satisfaction[i]` 。

返回厨师在准备了一定数量的菜肴后可以获得的最大 **like-time 系数** 总和。

你可以按 **任意** 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。

![1402](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1402.jpg)

**思路**：可以任意顺序安排做菜的顺序，把 satisfaction 从大到小排序。f(k)=k⋅a[0]+(k−1)⋅a[1]+⋯+2⋅a[k−2]+a[k−1] -> f(k)=f(k−1)+(a[0]+a[1]+⋯+a[k−1])

```java
class Solution {
    public int maxSatisfaction(int[] satisfaction) {
        Arrays.sort(satisfaction);
        int f = 0, s = 0;
        for (int i = satisfaction.length - 1; i >= 0; i --) {
            s += satisfaction[i];
            if (s < 0) {
                break;
            }
            f += s;
        }
        return f;
    }
}
```

### 1488. 避免洪水泛滥

你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 `n` 个湖泊下雨前是空的，那么它就会装满水。如果第 `n` 个湖泊下雨前是 **满的** ，这个湖泊会发生 **洪水** 。你的目标是避免任意一个湖泊发生洪水。

给你一个整数数组 `rains` ，其中：

- `rains[i] > 0` 表示第 `i` 天时，第 `rains[i]` 个湖泊会下雨。
- `rains[i] == 0` 表示第 `i` 天没有湖泊会下雨，你可以选择 **一个** 湖泊并 **抽干** 这个湖泊的水。

请返回一个数组 `ans` ，满足：

- `ans.length == rains.length`
- 如果 `rains[i] > 0` ，那么`ans[i] == -1` 。
- 如果 `rains[i] == 0` ，`ans[i]` 是你第 `i` 天选择抽干的湖泊。

如果有多种可行解，请返回它们中的 **任意一个** 。如果没办法阻止洪水，请返回一个 **空的数组** 。

请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。

![1488](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1488.jpg)

**思路**

**思考如何在洪水即将发生时，进行抽干操作**。使用有序集合 st 存储那些在某些日期没有下雨的日子。这些晴天日子可以被用来在湖泊即将发生洪水时，有选择地抽干湖泊，st 的排序方式是按照晴天日子的顺序排列的：

- 若 `rains[i]=0`，则将 i 加入有序集合 `st`。
- 若 `rains[i]>0`，表示第 `rains[i]` 湖泊将下雨，令 `ans[i]=−1` 表示这一天的湖泊不可抽干：
  - 若第 `rains[i]` 是第一次下雨，则此时不会发生洪水。
  - 否则我们需要在有序集合 `st` 中找到大于等于该湖泊上一次下雨天数的最小索引 `idx`（可以用二分查找实现），如果 `idx `不存在（即没有晴天可以用于抽干），此时不能避免洪水的发生，按照题目要求返回一个空数组。否则我们令 `ans[idx]=rains[i]`，并在 `st` 中删除 `idx`，表示我们会在第 `idx` 天抽干 `rains[i]` 湖泊的水来避免第 i 天洪水的发生。

```java
class Solution {
    public int[] avoidFlood(int[] rains) {
        int[] ans = new int[rains.length];
        Arrays.fill(ans, 1);
        TreeSet<Integer> st = new TreeSet<>();
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < rains.length; i ++) {
            if (rains[i] == 0) {
                st.add(i);
            } else {
                ans[i] = -1;
                if (map.containsKey(rains[i])) {
                    var a = st.ceiling(map.get(rains[i]));
                    if (a == null) {
                        return new int[0];
                    }
                    ans[a] = rains[i];
                    st.remove(a);
                }
                map.put(rains[i], i);
            }
        }
        return ans;
    }
}
```

### 1465. 切割后面积最大的蛋糕

矩形蛋糕的高度为 `h` 且宽度为 `w`，给你两个整数数组 `horizontalCuts` 和 `verticalCuts`，其中：

- `horizontalCuts[i]` 是从矩形蛋糕顶部到第 `i` 个水平切口的距离
- `verticalCuts[j]` 是从矩形蛋糕的左侧到第 `j` 个竖直切口的距离

请你按数组 _`horizontalCuts`_ 和 _`verticalCuts`_ 中提供的水平和竖直位置切割后，请你找出 **面积最大** 的那份蛋糕，并返回其 **面积** 。由于答案可能是一个很大的数字，因此需要将结果 **对** `109 + 7` **取余** 后返回。

![1465](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1465.jpg)

**思路**

可以这样理解，先横着切，那么间隔最大的那两刀，就决定了最大的那条蛋糕，它包含着最终面积最大的那份蛋糕。接下来只需要知道竖着切时，两刀的最大间隔是多少，就知道了蛋糕的最大面积。

```java
class Solution {
    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {
        int maxh = getMax(h, horizontalCuts);
        int maxv = getMax(w, verticalCuts);
        return (int)((long)maxh * maxv % 1000000007);
    }
    int getMax(int border, int[] arr) {
        Arrays.sort(arr);
        int pre = 0, res = 0;
        for (int x : arr) {
            res = Math.max(res, x - pre);
            pre = x;
        }
        return Math.max(res, border - pre);
    }
}
```

### 2178. 拆分成最多数目的正偶数之和

给你一个整数 finalSum 。请你将它拆分成若干个 互不相同 的正偶数之和，且拆分出来的正偶数数目 最多 。

- 比方说，给你`finalSum = 12`，那么这些拆分是 符合要求 的（互不相同的正偶数且和为 `finalSum`）：`(2 + 10) ，(2 + 4 + 6) 和 (4 + 8)` 。它们中，`(2 + 4 + 6) `包含最多数目的整数。

注意 `finalSum` 不能拆分成 `(2 + 2 + 4 + 4)` ，因为拆分出来的整数必须互不相同。
请你返回一个整数数组，表示将整数拆分成 最多 数目的正偶数数组。如果没有办法将 `finalSum` 进行拆分，请你返回一个 空 数组。你可以按 任意 顺序返回这些整数。

![拆分成最多数目的正偶数之和](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2178.jpg)

```java
class Solution {
    public List<Long> maximumEvenSplit(long finalSum) {
        List<Long> res = new ArrayList<>();
        if (finalSum % 2 != 0) {
            return res;
        }
        for (long i = 2; i <= finalSum; i += 2) {
            res.add(i);
            finalSum -= i;
        }
        int k = res.size() - 1;
        res.set(k, res.get(k) + finalSum);
        return res;
    }
}
```

### 2578. 最小和分割

给你一个正整数 `num` ，请你将它分割成两个非负整数 `num1` 和 `num2` ，满足：

- `num1` 和 `num2` 直接连起来，得到 `num` 各数位的一个排列。
  - 换句话说，`num1` 和 `num2` 中所有数字出现的次数之和等于 `num` 中所有数字出现的次数。
- `num1` 和 `num2` 可以包含前导 0 。

请你返回 `num1` 和 `num2` 可以得到的和的 **最小** 值。

**注意**：

- `num` 保证没有前导 0 。
- `num1` 和 `num2` 中数位顺序可以与 `num` 中数位顺序不同。

![2578](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2578.jpg)

```java
class Solution {
    public int splitNum(int num) {
        char[] stnum = Integer.toString(num).toCharArray();
        Arrays.sort(stnum);
        int num1 = 0, num2 = 0;
        for (int i = 0; i < stnum.length; ++i) {
            if (i % 2 == 0) {
                num1 = num1 * 10 + (stnum[i] - '0');
            } else {
                num2 = num2 * 10 + (stnum[i] - '0');
            }
        }
        return num1 + num2;
    }
}
```

### 2580. 统计将重叠区间合并成组的方案数

给你一个二维整数数组 `ranges` ，其中 `ranges[i] = [starti, endi]` 表示 `starti` 到 `endi` 之间（包括二者）的所有整数都包含在第 `i` 个区间中。

你需要将 `ranges` 分成 **两个** 组（可以为空），满足：

- 每个区间只属于一个组。
- 两个有 **交集** 的区间必须在 **同一个** 组内。

如果两个区间有至少 **一个** 公共整数，那么这两个区间是 **有交集** 的。

- 比方说，区间 `[1, 3]` 和 `[2, 5]` 有交集，因为 `2` 和 `3` 在两个区间中都被包含。

请你返回将 `ranges` 划分成两个组的 **总方案数** 。由于答案可能很大，将它对 `109 + 7` **取余** 后返回。

![2580](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2580.jpg)

```java
class Solution {
    static final int MOD = 1000000007;
    public int countWays(int[][] ranges) {
        Arrays.sort(ranges, (a, b) -> a[0] - b[0]);
        int res = 1, n = ranges.length;
        for (int i = 0; i < n;) {
            int r = ranges[i][1];
            int j = i + 1;
            while (j < n && ranges[j][0] <= r) {
                r = Math.max(r, ranges[j][1]);
                j ++;
            }
            res = res * 2 % MOD;
            i = j;
        }
        return res;
    }
}
```

### 2600. K 件物品的最大和

袋子中装有一些物品，每个物品上都标记着数字 1 、0 或 -1 。

给你四个非负整数 numOnes 、numZeros 、numNegOnes 和 k 。

袋子最初包含：

- `numOnes `件标记为 1 的物品。
- `numZeroes `件标记为 0 的物品。
- `numNegOnes `件标记为 -1 的物品。

现计划从这些物品中恰好选出 k 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。

![K 件物品的最大和](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2600.jpg)

```java
class Solution {
    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        return k <= numOnes ? k : (k - numOnes - numZeros < 0 ? numOnes : 2 * numOnes - k + numZeros);
    }
}
```

### 2952. 需要添加的硬币的最小数量

给你一个下标从 **0** 开始的整数数组 `coins`，表示可用的硬币的面值，以及一个整数 `target` 。

如果存在某个 `coins` 的子序列总和为 `x`，那么整数 `x` 就是一个 **可取得的金额** 。

返回需要添加到数组中的 **任意面值** 硬币的 **最小数量** ，使范围 `[1, target]` 内的每个整数都属于 **可取得的金额** 。

数组的 **子序列** 是通过删除原始数组的一些（**可能不删除**）元素而形成的新的 **非空** 数组，删除过程不会改变剩余元素的相对位置。

![2952](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2952.jpg)

**思路**

我们从1开始，按顺序进行考虑能否获得该金额。定义`curMax`为当前判断的能否获得的金额。对`coins`进行排序。我们能够获得`[0,curMax−1]`范围内对金额，所以，初始情况下，`curMax=1`，我们只能获得0这个金额。

- 如果当前`coins[i]≤curMax`，将`coins[i]`添加进来，能够获得的金额范围变成了`[0,curMax+coins[i]−1]`，即接下来要判断能否获得的金额变成了`curMax+coins[i]`；

- 如果当前`coins[i]>curMaxcoins[i]`，那么说明当前`curMax`是得不到的，那么肯定需要额外添加`curMax`这个金额的银币进来，所以此时能够获得的金额范围变成了`[0,curMax+curMax−1]`，即接下来要判断能否获得的金额变成了`curMax+curMax`，同时需要添加一枚金额为curMax的硬币。

就这样一直往后处理，直到`curMax>target`，然后返回添加的硬币数量即可。

```java
class Solution {
    public int minimumAddedCoins(int[] coins, int target) {
        int n = coins.length;
        Arrays.sort(coins);
        int curMax = 1;
        int i = 0;
        int cnt = 0;
        while (curMax <= target) {
            if (i < n && coins[i] <= curMax) {
                curMax += coins[i ++];
            } else {
                curMax <<= 1;
                cnt ++;
            }
        }
        return cnt;
    }
}
```

## 字符串

### 415. 字符串相加

给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

![字符串相加](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/415.jpg)

```java
class Solution {
    public String addStrings(String num1, String num2) {
        int l1 = num1.length(), l2 = num2.length();
        StringBuilder sb = new StringBuilder();
        int cur = 0;
        for (int i = l1 - 1, j = l2 - 1; i >= 0 || j >= 0;) {
            if (i >= 0) {
                cur += num1.charAt(i --) - '0';
            }
            if (j >= 0) {
                cur += num2.charAt(j --) - '0';
            }
            sb.append(cur % 10);
            cur /= 10;
        }
        if (cur != 0) {
            sb.append(cur);
        }
        return sb.reverse().toString();
    }
}
```

### 2446. 判断两个事件是否存在冲突

给你两个字符串数组 event1 和 event2 ，表示发生在同一天的两个闭区间时间段事件，其中：

- `event1 = [startTime1, endTime1]` 且
- `event2 = [startTime2, endTime2]`
  事件的时间为有效的 24 小时制且按 HH:MM 格式给出。

当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 冲突 。

如果两个事件之间存在冲突，返回 true ；否则，返回 false 。

![判断两个事件是否存在冲突](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2446.jpg)

```java
class Solution {
    public boolean haveConflict(String[] event1, String[] event2) {
        return !(event1[1].compareTo(event2[0]) < 0 || event2[1].compareTo(event1[0]) < 0);
    }
}
```

### 2788. 按分隔符拆分字符串

给你一个字符串数组 `words` 和一个字符 `separator` ，请你按 `separator` 拆分 `words` 中的每个字符串。

返回一个由拆分后的新字符串组成的字符串数组**，不包括空字符串** 。

**注意**

- `separator` 用于决定拆分发生的位置，但它不包含在结果字符串中。
- 拆分可能形成两个以上的字符串。
- 结果字符串必须保持初始相同的先后顺序。

![2788](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2788.jpg)

```java
class Solution {
    public List<String> splitWordsBySeparator(List<String> words, char separator) {
        List<String> ans = new ArrayList<>();
        for (String s : words) {
            ans.addAll(split_s(s, separator));
        }
        return ans;
    }
    List<String> split_s(String s, char separator) {
        List<String> res = new ArrayList<>();
        for (int i = 0, j = 0; i < s.length(); i ++) {
            j = i;
            StringBuilder sb = new StringBuilder();
            while (j < s.length() && s.charAt(j) != separator) {
                sb.append(s.charAt(j ++));
            }
            if (!"".equals(sb.toString().trim())) {
                res.add(sb.toString());
            }
            i = j;
        }
        return res;
    }
}
```

## 数组

### 57. 插入区间

给你一个 **无重叠的** ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

![57. 插入区间](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/57.jpg)

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        int n = intervals.length;
        List<int[]> res = new ArrayList<>();
        boolean flag = false;
        for (int[] x : intervals) {
            if (x[1] < newInterval[0]) {
                res.add(x);
            } else if (x[0] > newInterval[1]) {
                if (!flag) {
                    flag = true;
                    res.add(newInterval);
                }
                res.add(x);
            } else {
                newInterval[0] = Math.min(x[0], newInterval[0]);
                newInterval[1] = Math.max(x[1], newInterval[1]);
            }
        }
        if (!flag) {
            res.add(newInterval);
        }
        return res.toArray(new int[res.size()][]);
    }
}
```

### 1094. 拼车

车上最初有 `capacity` 个空座位。车 **只能** 向一个方向行驶（也就是说**，不允许掉头或改变方向**）

给定整数 `capacity` 和一个数组 `trips` ,  `trip[i] = [numPassengersi, fromi, toi]` 表示第 `i` 次旅行有 `numPassengersi` 乘客，接他们和放他们的位置分别是 `fromi` 和 `toi` 。这些位置是从汽车的初始位置向东的公里数。

当且仅当你可以在所有给定的行程中接送所有乘客时，返回 `true`，否则请返回 `false`。

![1094](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1094.jpg) 

**使用差分数组的方法解决：使用`O(1)`时间复杂度实现，对数组中连续子数组的操作，转变成对差分数组 d 中两个数的操作**

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int[] diff = new int[1001];
        for (int[] trip : trips) {
            int num = trip[0], from = trip[1], to = trip[2];
            diff[from] += num;
            diff[to] -= num;
        }
        int s = 0;
        for (int x : diff) {
            s += x;
            if (s > capacity) {
                return false;
            }
        }
        return true;
    }
}
```

### 2731. 移动机器人

有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 **0** 开始的整数数组 `nums` 表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。

给你一个字符串 `s` ，每个字符按顺序分别表示每个机器人移动的方向。`'L'` 表示机器人往左或者数轴的负方向移动，`'R'` 表示机器人往右或者数轴的正方向移动。

当两个机器人相撞时，它们开始沿着原本相反的方向移动。

请你返回指令重复执行 `d` 秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对 `109 + 7` 取余后返回。

**注意**：

- 对于坐标在 `i` 和 `j` 的两个机器人，`(i,j)` 和 `(j,i)` 视为相同的坐标对。也就是说，机器人视为无差别的。
- 当机器人相撞时，它们 **立即改变** 它们的前进方向，这个过程不消耗任何时间。
- 当两个机器人在同一时刻占据相同的位置时，就会相撞。
  - 例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 2 并往左移动，下一秒，它们都将占据位置 1，并改变方向。再下一秒钟后，第一个机器人位于位置 0 并往左移动，而另一个机器人位于位置 2 并往右移动。
  - 例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 1 并往左移动，下一秒，第一个机器人位于位置 0 并往左行驶，而另一个机器人位于位置 1 并往右移动。

![2731](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2731.jpg)

**思路**

> 1. 两个机器人相互碰撞, 只进行方向交换, 并且机器人是视为无差别的, 那么可以看做所有机器人之间不存在碰撞, 可以相互穿过，只需要将机器人根据对应方向加上或减去 d 秒移动的距离(d 个单位长度)。
>
> 2. 然后将移动后的坐标点排序, 来计算两两之间的距离。

下图 表示在 O(n)复杂度, 求两两之间的距离和 (有序的)

![2731_1](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2731_1.jpg)

```java
class Solution {
    public int sumDistance(int[] nums, String s, int d) {
        int n = nums.length;
        long[] arr = new long[n];
        for (int i = 0; i < n; i ++) {
            arr[i] = nums[i] + (s.charAt(i) == 'R' ? d : -d);
        }
        Arrays.sort(arr);
        final int MOD = 1000000007;
        long res = 0, sum = 0;
        for (int i = 1; i < n; i ++) {
            long x = arr[i] - arr[i - 1];
            sum = sum % MOD + (i * x) % MOD;
            res = res % MOD + sum % MOD;
        }
        return (int) res % MOD;
    }
}
```

### 2735. 收集巧克力

给你一个长度为 `n` 、下标从 **0** 开始的整数数组 `nums` ，表示收集不同巧克力的成本。每个巧克力都对应一个不同的类型，最初，位于下标 `i` 的巧克力就对应第 `i` 个类型。

在一步操作中，你可以用成本 `x` 执行下述行为：

- 同时修改所有巧克力的类型，将巧克力的类型 `ith` 修改为类型 `((i + 1) mod n)th`。

假设你可以执行任意次操作，请返回收集所有类型巧克力所需的最小成本。

![2735](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2735.jpg)

```java
class Solution {
    public long minCost(int[] nums, int x) {
        int n = nums.length;
        int[] f = new int[n];
        System.arraycopy(nums, 0, f, 0, n);
        long ans = getSum(f);
        for (int k = 1; k < n; k ++) {
            for (int i = 0; i < n; i ++) {
                f[i] = Math.min(f[i], nums[(i + k) % n]);
            }
            ans = Math.min(ans, (long) k * x + getSum(f));
        }
        return ans;
    }
    long getSum(int[] f) {
        long sum = 0;
        for (int x : f) {
            sum += x;
        }
        return sum;
    }
}
```

### 2765. 最长交替子数组

给你一个下标从 **0** 开始的整数数组 `nums` 。如果 `nums` 中长度为 `m` 的子数组 `s` 满足以下条件，我们称它是一个 **交替子数组** ：

- `m` 大于 `1` 。
- `s1 = s0 + 1` 。
- 下标从 **0** 开始的子数组 `s` 与数组 `[s0, s1, s0, s1,...,s(m-1) % 2]` 一样。也就是说，`s1 - s0 = 1` ，`s2 - s1 = -1` ，`s3 - s2 = 1` ，`s4 - s3 = -1` ，以此类推，直到 `s[m - 1] - s[m - 2] = (-1)m` 。

请你返回 `nums` 中所有 **交替** 子数组中，最长的长度，如果不存在交替子数组，请你返回 `-1` 。

子数组是一个数组中一段连续 **非空** 的元素序列。

![2765](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2765.jpg)

```java
class Solution {
    public int alternatingSubarray(int[] nums) {
        int res = -1, n = nums.length;
        for (int i = 0; i < n; i ++) {
            int j = i;
            int k = 1;
            while (j + 1 < n && nums[j + 1] - nums[j] == k) {
                j ++;
                k *= -1;
            }
            if (j - i + 1 > 1) {
                res = Math.max(res, j - i + 1);
            }
        }
        return res;
    }
}
```

### 2815. 数组中的最大数对和

给你一个下标从 0 开始的整数数组 nums 。请你从 nums 中找出和 最大 的一对数，且这两个数数位上最大的数字相等。

返回最大和，如果不存在满足题意的数字对，返回 -1 。

![2815](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2815.jpg)

```java
class Solution {
    public int maxSum(int[] nums) {
        int ans = -1;
        int[] max_val = new int[10];
        Arrays.fill(max_val, Integer.MIN_VALUE);
        for (int x : nums) {
            int max_idx = getMax(x);
            ans = Math.max(ans, x + max_val[max_idx]);
            max_val[max_idx] = Math.max(max_val[max_idx], x);
        }
        return ans;
    }
    int getMax(int x) {
        int max = 0;
        while (x > 0) {
            max = Math.max(max, x % 10);
            x /= 10;
        }
        return max;
    }
}
```

## 链表

### 2487. 从链表中移除节点

给你一个链表的头节点 `head` 。

移除每个右侧有一个更大数值的节点。

返回修改后链表的头节点 `head` 。

![2487](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2487.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNodes(ListNode head) {
        head = reverse(head);
        var p = head;
        while(p.next != null) {
            if (p.val > p.next.val) {
                p.next = p.next.next;
            } else {
                p = p.next;
            }
        }
        return reverse(head);
    }
    ListNode reverse(ListNode head) {
        var dummy = new ListNode(-1);
        while(head != null) {
            var p = head.next;
            head.next = dummy.next;
            dummy.next = head;
            head = p;
        }
        return dummy.next;
    }
}
```

### 2816. 翻倍以链表形式表示的数字

给你一个 非空 链表的头节点 head ，表示一个不含前导零的非负数整数。

将链表 翻倍 后，返回头节点 head 。

![2816. 翻倍以链表形式表示的数字](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2816.jpg)

**翻转链表**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode doubleIt(ListNode head) {
        ListNode p = reverse(head);
        ListNode dummy = new ListNode(-1);
        dummy.next = p;
        int cur = 0;
        while(p != null) {
            cur += p.val * 2;
            p.val = cur % 10;
            cur /= 10;
            p = p.next;
        }
        dummy.next = reverse(dummy.next);
        if (cur != 0) {
            ListNode node = new ListNode(cur);
            node.next = dummy.next;
            dummy.next = node;
        }
        return dummy.next;
    }
    ListNode reverse(ListNode head) {
        ListNode dummy = new ListNode(-1), p = head;
        while(p != null) {
            ListNode temp = p.next;
            p.next = dummy.next;
            dummy.next = p;
            p = temp;
        }
        return dummy.next;
    }
}
```

**不翻转链表（推荐使用）**

```java
class Solution {
    public ListNode doubleIt(ListNode head) {
        if (head.val >= 5) {
            head = new ListNode(0, head);
        }
        var cur = head;
        while (cur != null) {
            cur.val = cur.val * 2 % 10;
            if (cur.next != null && cur.next.val >= 5) {
                cur.val += 1;
            }
            cur = cur.next;
        }
        return head;
    }
}
```

## 二分

### 34. 在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

![34. 在排序数组中查找元素的第一个和最后一个位置](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/34.jpg)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] res = new int[]{-1, -1};
        if (nums.length == 0) {
            return res;
        }
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        if (nums[l] == target) {
            res[0] = l;
        }
        l = 0; r = nums.length - 1;
        while (l < r) {
            int mid = (l + r + 1) / 2;
            if (nums[mid] > target) {
                r = mid - 1;
            } else {
                l = mid;
            }
        }
        if (nums[r] == target) {
            res[1] = r;
        }
        return res;
    }
}
```

### 153. 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 4 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

**注意**，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

![153. 寻找旋转排序数组中的最小值](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/153.jpg)

```java
class Solution {
    public int findMin(int[] nums) {
        int l = 0, r = nums.length - 1;
        if (nums[r] >= nums[0]) {
            return nums[0];
        }
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] < nums[0]) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return nums[r];
    }
}
```

### 167. 两数之和 II - 输入有序数组

给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。

以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

![两数之和 II - 输入有序数组](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/167.jpg)

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int i = 0, j = numbers.length - 1;
        while (i < j) {
            int x = numbers[i] + numbers[j];
            if (x == target) {
                return new int[]{i + 1, j + 1};
            } else if (x < target) {
                i ++;
            } else {
                j --;
            }
        }
        return new int[]{0, 0};
    }
}
```

### 275. H 指数

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数，`citations` 已经按照 **升序排列** 。计算并返回该研究者的 h 指数。

[h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：h 代表“高引用次数”（high citations），一名科研人员的 `h` 指数是指他（她）的 （`n` 篇论文中）**总共**有 `h` 篇论文分别被引用了**至少** `h` 次。

请你设计并实现对数时间复杂度的算法解决此问题。

![275](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/275.jpg)

```java
class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (citations[mid] >= n - mid) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return n - l;
    }
}
```

### 2251. 花期内花的数目

给你一个下标从 **0** 开始的二维整数数组 `flowers` ，其中 `flowers[i] = [starti, endi]` 表示第 `i` 朵花的 **花期** 从 `starti` 到 `endi` （都 **包含**）。同时给你一个下标从 **0** 开始大小为 `n` 的整数数组 `people` ，`people[i]` 是第 `i` 个人来看花的时间。

请你返回一个大小为 `n` 的整数数组 `answer` ，其中 `answer[i]`是第 `i` 个人到达时在花期内花的 **数目** 。

![2251](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2251.jpg)

```java
class Solution {
    public int[] fullBloomFlowers(int[][] flowers, int[] people) {
        int n = flowers.length;
        int[] start = new int[n], end = new int[n];
        for (int i = 0; i < n; i ++) {
            start[i] = flowers[i][0];
            end[i] = flowers[i][1];
        }
        Arrays.sort(start);
        Arrays.sort(end);
        int m = people.length;
        int[] ans = new int[m];
        for (int i = 0; i < m; i ++) {
            int x = find(start, people[i] + 1);
            int y = find(end, people[i]);
            ans[i] = x - y;
        }
        return ans;
    }
    int find(int[] arr, int x) {
        int l = 0, r = arr.length - 1, res = arr.length;
        while (l <= r) {
            int mid = l + r >> 1;
            if (arr[mid] < x) {
                l = mid + 1;
            } else {
                res = mid;
                r = mid - 1;
            }
        }
        return res;
    }
}
```

### 2560. 打家劫舍 IV

沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。

由于相邻的房屋装有相互连通的防盗系统，所以小偷 `不会窃取相邻的房屋` 。

小偷的 `窃取能力` 定义为他在窃取过程中能从单间房屋中窃取的 `最大金额` 。

给你一个整数数组 nums 表示每间房屋存放的现金金额。形式上，从左起第 i 间房屋中放有 nums[i] 美元。

另给你一个整数 k ，表示窃贼将会窃取的 最少 房屋数。小偷总能窃取至少 k 间房屋。

返回小偷的 `最小` 窃取能力。

![2560](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2560.jpg)

```java
class Solution {
    public int minCapability(int[] nums, int k) {
        int lower = Arrays.stream(nums).min().getAsInt();
        int upper = Arrays.stream(nums).max().getAsInt();
        while (lower <= upper) {
            int middle = (lower + upper) / 2;
            int count = 0;
            boolean visited = false;
            for (int x : nums) {
                if (x <= middle && !visited) {
                    count++;
                    visited = true;
                } else {
                    visited = false;
                }
            }
            if (count >= k) {
                upper = middle - 1;
            } else {
                lower = middle + 1;
            }
        }
        return lower;
    }
}
```

### 2594. 修车的最少时间

给你一个整数数组 ranks ，表示一些机械工的 能力值 。ranksi 是第 i 位机械工的能力值。能力值为 r 的机械工可以在 r \* n2 分钟内修好 n 辆车。

同时给你一个整数 cars ，表示总共需要修理的汽车数目。

请你返回修理所有汽车 最少 需要多少时间。

注意：所有机械工可以同时修理汽车。

![2594. 修车的最少时间](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2594.jpg)

```java
class Solution {
    public long repairCars(int[] ranks, int cars) {
        long left = 1, right = 1l * ranks[0] * cars * cars;
        while (left < right) {
            long mid = (right - left) / 2 + left;
            if (check(ranks, cars, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return right;
    }
    boolean check(int[] ranks, int cars, long k) {
        long cnt = 0;
        for (int x : ranks) {
            cnt += (long) Math.sqrt(k / x);
        }
        return cnt >= cars;
    }
}
```

### 2817. 限制条件下元素之间的最小绝对差

给你一个下标从 0 开始的整数数组 nums 和一个整数 x 。

请你找到数组中下标距离至少为 x 的两个元素的 差值绝对值 的 最小值 。

换言之，请你找到两个下标 i 和 j ，满足 `abs(i - j) >= x 且 abs(nums[i] - nums[j])` 的值最小。

请你返回一个整数，表示下标距离至少为 x 的两个元素之间的差值绝对值的 最小值 。

![2817](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2817.jpg)

**二分法**

枚举 i 和 j ，其中 j = i + x，这样从 0 ~ i 范围内都是 nums[j] 可以配对的数字。 将 0 ~ i 的数字排序之后，就可以使用二分查找寻找其中最接近 nums[j] 的数字了。

```java
class Solution {
    public int minAbsoluteDifference(List<Integer> nums, int x) {
        int n = nums.size(), ans = Integer.MAX_VALUE;
        List<Integer> ls = new ArrayList();         // 维护前面元素的有序序列（升序）
        for (int i = 0, j = x; j < n; ++i, ++j) {
            // 将nums[i]加入有序序列ls，使用二分查找寻找nums[i]应该插入的位置。
            int l = 0, r = ls.size(), v = nums.get(i);
            while (l < r) {
                int mid = l + r >> 1;
                if (ls.get(mid) <= v) l = mid + 1;
                else r = mid;
            }
            ls.add(l, v);

            // 使用二分查找寻找前面序列中最后一个<=nums[j]的元素
            l = 0;
            r = ls.size() - 1;
            v = nums.get(j);
            while (l < r) {
                int mid = l + r + 1 >> 1;
                if (ls.get(mid) > v) r = mid - 1;
                else l = mid;
            }
            // 使用和nums[j]最接近的元素更新答案
            ans = Math.min(ans, Math.abs(v - ls.get(l)));
            if (l + 1 < ls.size()) ans = Math.min(ans, Math.abs(ls.get(l + 1) - v));
        }
        return ans;
    }
}
```

**使用 API**
TreeSet 会自动排序，关于 TreeSet 可见：https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeSet.html#ceiling(E)

- floor()：返回集合中小于或等于给定元素的最大元素，如果没有这样的元素，则返回 null。
- ceiling()：返回集合中大于或等于给定元素的最小元素，如果不存在这样的元素则返回 null。

```java
class Solution {
    public int minAbsoluteDifference(List<Integer> nums, int x) {
        var a = nums.stream().mapToInt(i -> i).toArray();
        int ans = Integer.MAX_VALUE, n = a.length;
        var s = new TreeSet<Integer>();
        s.add(Integer.MAX_VALUE);
        s.add(Integer.MIN_VALUE / 2);
        for (int i = x; i < n; i ++) {
            s.add(a[i - x]);
            int y = a[i];
            ans = Math.min(ans, Math.min(s.ceiling(y) - y, y - s.floor(y)));
        }
        return ans;
    }
}
```

## 双指针

### 15. 三数之和

给你一个整数数组 nums ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j、i != k 且 j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0 `。请

你返回所有和为 0 且不重复的三元组。

> 注意：答案中不可以包含重复的三元组。

![三数之和](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/15.jpg)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        for (int l = 0; l < n; l ++) {
            if (l > 0 && nums[l] == nums[l - 1]) {
                continue;
            }
            int r = n - 1;
            int target = -nums[l];
            for (int m = l + 1; m < n; m ++) {
                if (m > l + 1 && nums[m] == nums[m - 1]) {
                    continue;
                }
                while (m < r && nums[m] + nums[r] > target) {
                    r --;
                }
                if (m == r) {
                    break;
                }
                if (nums[m] + nums[r] == target) {
                    ans.add(List.of(nums[l], nums[m], nums[r]));
                }
            }
        }
        return ans;
    }
}
```

### 18. 四数之和

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a、b、c 和 d 互不相同`
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 任意顺序 返回答案 。

![四数之和](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/18.jpg)

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        int n = nums.length;
        for (int a = 0; a < n - 3; a ++) {
            long x = nums[a];
            if (a > 0 && x == nums[a - 1]) continue;
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break;
            if (x + nums[n - 1] + nums[n - 2] + nums[n - 3] < target) continue;
            for (int b = a + 1; b < n - 2; b ++) {
                long y = nums[b];
                if (b > a + 1 && y == nums[b - 1]) continue;
                if (x + y + nums[b + 1] + nums[b + 1] > target) break;
                if (x + y + nums[n - 1] + nums[n - 2] < target) continue;
                int c = b + 1, d = n - 1;
                while (c < d) {
                    long s = x + y + nums[c] + nums[d];
                    if (s < target) {
                        c ++;
                    } else if (s > target) {
                        d --;
                    } else {
                        ans.add(List.of((int) x, (int) y, nums[c], nums[d]));
                        for (c ++; c < d && nums[c] == nums[c - 1]; c ++);
                        for (d --; d > c && nums[d] == nums[d + 1]; d --);
                    }
                }
            }
        }
        return ans;
    }
}
```

### 228. 汇总区间

给定一个 无重复元素 的 有序 整数数组 nums 。

返回 **恰好覆盖数组中所有数字** 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。

列表中的每个区间范围 [a,b] 应该按如下格式输出：

- `"a->b" ，如果 a != b`
- `"a" ，如果 a == b`

![228. 汇总区间](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/228.jpg)

```java
class Solution {
    public List<String> summaryRanges(int[] nums) {
        int n = nums.length;
        List<String> res = new ArrayList<>();
        for (int i = 0; i < n; i ++) {
            int j = i + 1;
            while (j < n && nums[j] == nums[j - 1] + 1) {
                j ++;
            }
            if (i + 1 == j) {
                res.add(Integer.toString(nums[i]));
            } else {
                res.add(nums[i] + "->" + nums[j - 1]);
            }
            i = j - 1;
        }
        return res;
    }
}
```

### 849. 到最近的人的最大距离

给你一个数组 seats 表示一排座位，其中 seats[i] = 1 代表有人坐在第 i 个座位上，seats[i] = 0 代表座位 i 上是空的（下标从 0 开始）。

至少有一个空座位，且至少有一人已经坐在座位上。

亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。

返回他到离他最近的人的最大距离。

![849. 到最近的人的最大距离](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/849.jpg)

```java
class Solution {
    public int maxDistToClosest(int[] seats) {
        int res = 0;
        for (int i = 0; i < seats.length; i ++) {
            if (seats[i] == 1) {
                continue;
            }
            int j = i + 1;
            while (j < seats.length && seats[j] == 0) {
                j ++;
            }
            if (i == 0 || j == seats.length) {
                res = Math.max(res, j - i);
            } else {
                res = Math.max(res, (j - i + 1) / 2);
            }
        }
        return res;
    }
}
```

### 1793. 好子数组的最大分数

给你一个整数数组 `nums` **（下标从 0 开始）**和一个整数 `k` 。

一个子数组 `(i, j)` 的 **分数** 定义为 `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)` 。一个 **好** 子数组的两个端点下标需要满足 `i <= k <= j` 。

请你返回 **好** 子数组的最大可能 **分数** 。

![1793](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1793.jpg)

同 [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

```java
class Solution {
    // 双指针
    public int maximumScore(int[] nums, int k) {
        int l = k, r = k, n = nums.length, res = 0;
        while (l >= 0 || r < n) {
            while (r < n && nums[r] >= nums[k]) r ++;
            while (l >= 0 && nums[l] >= nums[k]) l --;
            res = Math.max(res, (r - l - 1) * nums[k]);
            nums[k] = 0;
            if (l >= 0) nums[k] = Math.max(nums[k], nums[l]);
            if (r < n) nums[k] = Math.max(nums[k], nums[r]);
        }
        return res;
    }
    // 单调栈
    // public int maximumScore(int[] nums, int k) {
    //     int n = nums.length;
    //     int[] left = new int[n], right = new int[n];
    //     Deque<Integer> st = new ArrayDeque<>();
    //     for (int i = 0; i < n; i ++) {
    //         int x = nums[i];
    //         while (!st.isEmpty() && x <= nums[st.peek()]) {
    //             st.pop();
    //         }
    //         left[i] = st.isEmpty() ? -1 : st.peek();
    //         st.push(i);
    //     }
    //     st.clear();
    //     for (int i = n - 1; i >= 0; i --) {
    //         int x = nums[i];
    //         while (!st.isEmpty() && x <= nums[st.peek()]) {
    //             st.pop();
    //         }
    //         right[i] = st.isEmpty() ? n : st.peek();
    //         st.push(i);
    //     }
    //     int ans = 0;
    //     for (int i = 0; i < n; i ++) {
    //         int h = nums[i];
    //         int l = left[i];
    //         int r = right[i];
    //         if (l < k  && k < r) {
    //             ans = Math.max(ans, h * (r - l - 1));
    //         }
    //     }
    //     return ans;
    // }
}

```

### 2182. 构造限制重复的字符串

给你一个字符串 `s` 和一个整数 `repeatLimit` ，用 `s` 中的字符构造一个新字符串 `repeatLimitedString` ，使任何字母 **连续** 出现的次数都不超过 `repeatLimit` 次。你不必使用 `s` 中的全部字符。

返回 **字典序最大的** `repeatLimitedString` 。

如果在字符串 `a` 和 `b` 不同的第一个位置，字符串 `a` 中的字母在字母表中出现时间比字符串 `b` 对应的字母晚，则认为字符串 `a` 比字符串 `b` **字典序更大** 。如果字符串中前 `min(a.length, b.length)` 个字符都相同，那么较长的字符串字典序更大。

![2182](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2182.jpg)

```java
class Solution {
    public String repeatLimitedString(String s, int repeatLimit) {
        int[] hash = new int[26];
        for (char c : s.toCharArray()) {
            hash[c - 'a'] ++;
        }
        StringBuilder sb = new StringBuilder();
        int n = hash.length;
        for (int i = n - 1, j = n - 2, m = 0; i >= 0 && j >= 0;) {
            if (hash[i] == 0) {
                m = 0;
                i --;
            } else if (m < repeatLimit) {
                hash[i] --;
                sb.append((char)('a' + i));
                m ++;
            } else if (j >= i || hash[j] == 0) {
                j --;
            } else {
                hash[j] --;
                sb.append((char)('a' + j));
                m = 0;
            }
        }
        return sb.toString();
    }
}
```

## 数学

### 453. 最小操作次数使数组元素相等

给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。

![453. 最小操作次数使数组元素相等](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/453.jpg)

```java
class Solution {
    public int minMoves(int[] nums) {
        // 每次操作将会使 n - 1 个元素增加 1 <=> 将 1 个元素 减去 1
        int min = Integer.MAX_VALUE;
        for (int x : nums) {
            min = Math.min(min, x);
        }
        int res = 0;
        for (int x : nums) {
            res += x - min;
        }
        return res;
    }
}
```

### 2171. 拿出最少数目的绿豆

给定一个 **正整数** 数组 `beans` ，其中每个整数表示一个袋子里装的绿豆的数目。

请你从每个袋子中 **拿出** 一些豆子（也可以 **不拿出**），使得剩下的 **非空** 袋子中（即 **至少还有一颗** 绿豆的袋子）绿豆的数目 **相等**。一旦把绿豆从袋子中取出，你不能再将它放到任何袋子中。

请返回你需要拿出绿豆的 **最少数目**。

![2171](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2171.jpg)

**思路**

![2171_1](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2171_1.jpg)

```java
class Solution {
    public long minimumRemoval(int[] beans) {
        Arrays.sort(beans);
        long s = 0;
        for (int x : beans) {
            s += x;
        }
        long ans = s;
        int n = beans.length;
        for (int i = 0; i < n; ++i) {
            ans = Math.min(ans, s - (long) beans[i] * (n - i));
        }
        return ans;
    }
}

```

### 2544. 交替数字和

给你一个正整数 n 。n 中的每一位数字都会按下述规则分配一个符号：

- 最高有效位 上的数字分配到 正 号。
- 剩余每位上数字的符号都与其相邻数字相反。

返回所有数字及其对应符号的和。

![交替数字和](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2544.jpg)

```java
class Solution {
    public int alternateDigitSum(int n) {
        int res = 0, sign = 1;
        while (n > 0) {
            res += n % 10 * sign;
            sign = -sign;
            n /= 10;
        }
        return -sign * res;
    }
}
```

### 2807. 在链表中插入最大公约数

给你一个链表的头 `head` ，每个结点包含一个整数值。

在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 **最大公约数** 。

请你返回插入之后的链表。

两个数的 **最大公约数** 是可以被两个数字整除的最大正整数。

![2807](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2807.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode insertGreatestCommonDivisors(ListNode head) {
        ListNode p = head, q = head.next;
        while (q != null) {
            int t = gcd(p.val, q.val);
            ListNode insert = new ListNode(t);
            insert.next = q;
            p.next = insert;
            p = q;
            q = q.next;
        }
        return head;
    }
    int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
    }
}
```

## 动态规划

### 53. 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

![最大子数组和](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/53.jpg)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = Integer.MIN_VALUE, sum = 0;
        for (int x : nums) {
            sum = Math.max(sum, 0) + x;
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}
```

### 132. 分割回文串 II

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。

返回符合要求的 最少分割次数 。

![分割回文串 II](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/132.jpg)

```java
class Solution {
    public int minCut(String s) {
        s = " " + s;
        int n = s.length();
        int[] f = new int[n];
        boolean[][] g = new boolean[n][n];

        Arrays.fill(f, Integer.MAX_VALUE);
        for (int i = 0; i < n; i ++) {
            Arrays.fill(g[i], true);
        }

        for (int i = n - 1; i >= 0; i --) {
            for (int j = i + 1; j < n; j ++) {
                g[i][j] = (s.charAt(i) == s.charAt(j)) && g[i + 1][j - 1];
            }
        }

        f[0] = 0;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j <= i; j ++) {
                if (g[j][i] && j != 0) {
                    f[i] = Math.min(f[i], f[j - 1] + 1);
                }
            }
        }
        return f[n - 1] - 1;
    }
}
```

### 188. 买卖股票的最佳时机 IV

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

![188](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/188.jpg)

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        int[][][] f = new int[n + 1][k + 2][2];
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j <= k + 1; j ++) {
                Arrays.fill(f[i][j], Integer.MIN_VALUE / 2);
            }
        }
        for (int j = 1; j <= k + 1; j ++) {
            f[0][j][0] = 0;
        }
        for (int i = 0; i < n; i ++) {
            for (int j = 1; j <= k + 1; j ++) {
                f[i + 1][j][0] = Math.max(f[i][j][0], f[i][j][1] + prices[i]);
                f[i + 1][j][1] = Math.max(f[i][j][1], f[i][j - 1][0] - prices[i]);
            }
        }
        return f[n][k + 1][0];
    }
}
```

### 309. 买卖股票的最佳时机含冷冻期

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

![309](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/309.jpg)

```java
class Solution {
    public int maxProfit(int[] prices) {
        /**
        f[i][j]表示收益 j=0: 持有股票 j=1: 未持有股票，处于冷冻期 j=2: 未持有股票，未处于冷冻期
        f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i]);
        f[i][1] = f[i - 1][0] + prices[i];
        f[i][2] = max(f[i - 1][1], f[i - 1][2]);
        */
        int n = prices.length;
        if (n == 0) {
            return 0;
        }
        int[][] f = new int[n + 1][3];
        f[0][0] = -prices[0];
        for (int i = 1; i <= n; i ++) {
            f[i][0] = Math.max(f[i - 1][0], f[i - 1][2] - prices[i - 1]);
            f[i][1] = f[i - 1][0] + prices[i - 1];
            f[i][2] = Math.max(f[i - 1][1], f[i - 1][2]);
        }
        return Math.max(f[n][1], f[n][2]);

        // 优化空间
        // int f0 = -prices[0], f1 = 0, f2 = 0;
        // for (int x : prices) {
        //     int new_f0 = Math.max(f0, f2 - x);
        //     int new_f1 = f0 + x;
        //     int new_f2 = Math.max(f1, f2);
        //     f0 = new_f0;
        //     f1 = new_f1;
        //     f2 = new_f2;
        // }
        // return Math.max(f1, f2);
    }
}
```

### 322. 零钱兑换

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

![322](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/322.jpg)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        // f[i] 表示金额到i 需要的最少硬币数
        // f[i] = f[i - coins[j]] + 1, 0 < j < n 
        int[] f = new int[amount + 1];
        for (int i = 1; i <= amount; i ++) {
            f[i] = amount + 1;
            for (int x : coins) {
                if (i >= x) {
                    f[i] = Math.min(f[i], f[i - x] + 1);
                }
            }
        }
        return f[amount] > amount ? -1 : f[amount];
    }
}
```

### 337. 打家劫舍 III

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。

除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。

给定二叉树的 root 。返回 `在不触动警报的情况下` ，小偷能够盗取的最高金额 。

![337. 打家劫舍 III](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/337.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Map<TreeNode, Integer> f = new HashMap<>();
    Map<TreeNode, Integer> g = new HashMap<>();

    public int rob(TreeNode root) {
        dfs(root);
        return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0));
    }
    void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        dfs(root.right);
        f.put(root, root.val + g.getOrDefault(root.left, 0) + g.getOrDefault(root.right, 0));
        g.put(root, Math.max(f.getOrDefault(root.left, 0), g.getOrDefault(root.left, 0)) + Math.max(f.getOrDefault(root.right, 0), g.getOrDefault(root.right, 0)));
    }
}
```

### 518. 零钱兑换 II

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

![518](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/518.jpg)

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] f = new int[amount + 1];
        f[0] = 1;
        for (int x : coins) {
            for (int i = x; i <= amount; i ++) {
                f[i] += f[i - x];
            }
        }
        return f[amount];
    }
}
```

### 714. 买卖股票的最佳时机含手续费

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意**：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

![714](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/714.jpg)

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        /**
        f[i][0] = max(f[i - 1][0], f[i - 1][1] + prices[i] - fee)
        f[i][1] = max(f[i - 1][0] + fee - prices[i], f[i - 1][1])
        */
        int n = prices.length;
        int[][] f = new int[n + 1][2];
        f[0][1] = Integer.MIN_VALUE / 2;
        for (int i = 1; i <= n; i ++) {
            f[i][0] = Math.max(f[i - 1][0], f[i - 1][1] + prices[i - 1] - fee);
            f[i][1] = Math.max(f[i - 1][0] - prices[i - 1], f[i - 1][1]);
        }
        return f[n][0];

        // 优化空间
        // int f0 = 0, f1 = Integer.MIN_VALUE / 2;
        // for (int x : prices) {
        //     int new_f0 = Math.max(f0, f1 + x - fee);
        //     int new_f1 = Math.max(f0 - x, f1);
        //     f0 = new_f0;
        //     f1 = new_f1;
        // }
        // return f0;
    }
}
```

### 823. 带因子的二叉树

给出一个含有不重复整数元素的数组 arr ，每个整数 arr[i] 均大于 1。

用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

满足条件的二叉树一共有多少个？答案可能很大，返回 对 109 + 7 取余 的结果。

![823. 带因子的二叉树](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/823.jpg)

```java
class Solution {
    public int numFactoredBinaryTrees(int[] arr) {
        /**
        考虑以 arr[i] 为根结点的带因子的二叉树，那么它的所有子孙结点的值都小于 arr[i]
        将 arr 从小到大进行排序，那么对于以 arr[i] 为根结点的带因子的二叉树，它的子孙结点值的下标只能在区间 [0,i−1)
        f[i] 表示以第 i 个元素 为根的二叉树的数量
        如 2,3,4,6,8
        f[i]:
            无儿子：1
            有儿子：(3*8)、(8*3)、(4*6)、(6*4) 其中 4*6 的方案数=f[4] * f[6]
        O(n^2)
        */
        Arrays.sort(arr);
        int n = arr.length;
        long[] f = new long[n];
        Map<Integer, Integer> hash = new HashMap<>();
        for (int i = 0; i < n; i ++) {
            hash.put(arr[i], i);
        }
        long res = 0, MOD = 1000000007;
        for (int i = 0; i < n; i ++) {
            f[i] = 1;
            for (int j = 0; j < i; j ++) {
                if (arr[i] % arr[j] == 0) {
                    int d = arr[i] / arr[j];
                    if (hash.containsKey(d)) {
                        int k = hash.get(d);
                        f[i] = (f[i] + f[j] * f[k]) % MOD;
                    }
                }
            }
            res = (res + f[i]) % MOD;
        }
        return (int)res;
    }
}
```

### 918. 环形子数组的最大和

给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。

环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。

子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i <= k1, k2 <= j 其中 k1 % n == k2 % n 。

![环形子数组的最大和](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/918.jpg)

```java
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int maxS = Integer.MIN_VALUE, minS = 0;
        int maxF = 0, minF = 0, sum = 0;
        for (int x : nums) {
            maxF = Math.max(maxF, 0) + x;
            maxS = Math.max(maxS, maxF);
            minF = Math.min(minF, 0) + x;
            minS = Math.min(minS, minF);
            sum += x;
        }
        return sum == minS ? maxS : Math.max(maxS, sum - minS);
    }
}
```

### 931. 下降路径最小和

给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。

下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置`(row, col)`的下一个元素应当是 `(row + 1, col - 1)、(row + 1, col)` 或者` (row + 1, col + 1)` 。

![931. 下降路径最小和](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/931.jpg)

```java
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int n = matrix.length;
        int[][] dp = new int[n][n];
        System.arraycopy(matrix[0], 0, dp[0], 0, n);
        for (int i = 1; i < n; i ++) {
            for (int j = 0; j < n; j ++) {
                int mn = dp[i - 1][j];
                if (j > 0) {
                    mn = Math.min(mn, dp[i - 1][j - 1]);
                }
                if (j < n - 1) {
                    mn = Math.min(mn, dp[i - 1][j + 1]);
                }
                dp[i][j] = mn + matrix[i][j];
            }
        }
        return Arrays.stream(dp[n - 1]).min().getAsInt();
    }
}
```

![Java.lang.System.arraycopy() 方法](<imgs/leetcode/arraycopy().jpg>)

### 1155. 掷骰子等于目标和的方法数

这里有 `n` 个一样的骰子，每个骰子上都有 `k` 个面，分别标号为 `1` 到 `k` 。

给定三个整数 `n` , `k` 和 `target` ，返回可能的方式(从总共 `kn` 种方式中)滚动骰子的数量，使正面朝上的数字之和等于 `target` 。

答案可能很大，你需要对 `109 + 7` **取模** 。

![1155](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1155.jpg)

```java
class Solution {
    static final int MOD = 1000000007;
    public int numRollsToTarget(int n, int k, int target) {
        /**
        f[i][j] 投第i个骰子时，和为 j的方案数
        f[i + 1][j + 1] = f[i][j] + f[i][j - 1] + f[i][j - 2] + f[i][j - 3] + ... + f[i][j - k + 1]
        */
        int[][] f = new int[n + 1][target + 1];
        f[0][0] = 1;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < target; j ++) {
                for (int v = 0; v < k; v ++) {
                    if (j - v >= 0) {
                        f[i + 1][j + 1] = (f[i + 1][j + 1] + f[i][j - v]) % MOD;
                    }
                }
            }
        }
        return f[n][target];
    }
}
```

### 1696. 跳跃游戏 VI

给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。

一开始你在下标 `0` 处。每一步，你最多可以往前跳 `k` 步，但你不能跳出数组的边界。也就是说，你可以从下标 `i` 跳到 `[i + 1， min(n - 1, i + k)]` **包含** 两个端点的任意位置。

你的目标是到达数组最后一个位置（下标为 `n - 1` ），你的 **得分** 为经过的所有数字之和。

请你返回你能得到的 **最大得分** 。

![1696](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1696.jpg)

**思路**

当 `i<k` 时，我们计算的是 `f[0],f[1],⋯ ,f[i−1]` 的最大值。

当 `i≥ki` 时，我们计算的是 `f[i−k],f[i−k+1],⋯ ,f[i−1]` 的最大值。这是一个长度固定为 k 的滑动窗口最大值问题。

对于本题，我们维护一个 `f` 值从左到右严格递减的单调队列（双端队列）。在计算 `f[i] `时，需要保证队首就是转移来源最大值的下标，方法如下：

**出**：如果队首小于`i−k`，则弹出队首。注意单调队列只需保存下标。
**转移**：`f[i]=f[q[0]]+nums[i]`。其中 `q[0]` 表示单调队列 `q` 的队首，此时队首就是转移来源最大值的下标。
**入**：不断弹出队尾，直到队列为空，或者 `f[i]` 小于队尾对应的 `f` 值为止。然后把 `i` 加到队尾。

```java
class Solution {
    public int maxResult(int[] nums, int k) {
        /**
        f[i]表示到i处的最大得分
        f[i] = max(f[j] + nums[i]) max(i - k, 0) <= j < i
         */
        int n = nums.length;
        int[] f = new int[n];
        f[0] = nums[0];
        Deque<Integer> q = new ArrayDeque<>();
        q.add(0);
        for (int i = 1; i < n; i ++) {
            if (q.peekFirst() < i - k) {
                q.pollFirst();
            }
            f[i] = f[q.peekFirst()] + nums[i];
            while (!q.isEmpty() && f[i] >= f[q.peekLast()]) {
                q.pollLast();
            }
            q.add(i);
        }
        // for (int i = 1; i < n; i ++) {
        //     int mx = Integer.MIN_VALUE;
        //     for (int j = Math.max(i - k, 0); j < i; j ++) {
        //         mx = Math.max(mx, f[j]);
        //     }
        //     f[i] = mx + nums[i];
        // }
        return f[n - 1];
    }
}
```

### 1997. 访问完所有房间的第一天

 你需要访问 `n` 个房间，房间从 `0` 到 `n - 1` 编号。同时，每一天都有一个日期编号，从 `0` 开始，依天数递增。你每天都会访问一个房间。

最开始的第 `0` 天，你访问 `0` 号房间。给你一个长度为 `n` 且 **下标从 0 开始** 的数组 `nextVisit` 。在接下来的几天中，你访问房间的 **次序** 将根据下面的 **规则** 决定：

- 假设某一天，你访问 `i` 号房间。
- 如果算上本次访问，访问 `i` 号房间的次数为 **奇数** ，那么 **第二天** 需要访问 `nextVisit[i]` 所指定的房间，其中 `0 <= nextVisit[i] <= i` 。
- 如果算上本次访问，访问 `i` 号房间的次数为 **偶数** ，那么 **第二天** 需要访问 `(i + 1) mod n` 号房间。

请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 `109 + 7` 取余后的结果。

![1997](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1997.jpg)

```java
class Solution {
    public int firstDayBeenInAllRooms(int[] nextVisit) {
        /**
        f[i] 表示从「访问到房间 i 且次数为奇数」到「访问到房间 i 且次数为偶数」所需要的天数。
        由于 [j,i−1] 范围内的每个房间都需要「回访」，所以需要把这个范围内的 f 值都加起来，再算上房间 i 需要访问 2 次。
        f[i] = 2 + f[k], j <= k < i, 求f[k] 使用前缀和优化
         */
        final int MOD = 1_000_000_007;
        int n = nextVisit.length;
        long[] f = new long[n];
        for (int i = 0; i < n - 1; i ++) {
            int to = nextVisit[i];
            f[i + 1] = (f[i] * 2 - f[to] + 2 + MOD) % MOD;
        }
        return (int)f[n - 1];
    }
}
```

### 2008. 出租车的最大盈利

你驾驶出租车行驶在一条有 `n` 个地点的路上。这 `n` 个地点从近到远编号为 `1` 到 `n` ，你想要从 `1` 开到 `n` ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。

乘客信息用一个下标从 **0** 开始的二维数组 `rides` 表示，其中 `rides[i] = [starti, endi, tipi]` 表示第 `i` 位乘客需要从地点 `starti` 前往 `endi` ，愿意支付 `tipi` 元的小费。

**每一位** 你选择接单的乘客 `i` ，你可以 **盈利** `endi - starti + tipi` 元。你同时 **最多** 只能接一个订单。

给你 `n` 和 `rides` ，请你返回在最优接单方案下，你能盈利 **最多** 多少元。

**注意**：你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。

![2008](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2008.jpg)

```java
class Solution {
    public long maxTaxiEarnings(int n, int[][] rides) {
        /**
        f[i] 表示接受第 i个订单能获得的最大利润
        rides[i][0] > rides[j][1] 
        f[i] = f[j] + rides[i][1] - rides[i][0] + rides[i][2], f[i - 1];
        */
        Arrays.sort(rides, (a, b) -> a[1] - b[1]);
        int m = rides.length;
        long[] f = new long[m + 1];
        for (int i = 0; i < m; i ++) {
            int j = binary_search(rides, i, rides[i][0]);
            f[i + 1] = Math.max(f[i], f[j] + rides[i][1] - rides[i][0] + rides[i][2]);
        }
        return f[m];
    }
    int binary_search(int[][] rides, int r, int x) {
        int l = 0;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (x < rides[mid][1]) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
}
```

### 2369. 检查数组是否存在有效划分

给你一个下标从 **0** 开始的整数数组 `nums` ，你必须将数组划分为一个或多个 **连续** 子数组。

如果获得的这些子数组中每个都能满足下述条件 **之一** ，则可以称其为数组的一种 **有效** 划分：

1. 子数组 **恰** 由 `2` 个相等元素组成，例如，子数组 `[2,2]` 。
2. 子数组 **恰** 由 `3` 个相等元素组成，例如，子数组 `[4,4,4]` 。
3. 子数组 **恰** 由 `3` 个连续递增元素组成，并且相邻元素之间的差值为 `1` 。例如，子数组 `[3,4,5]` ，但是子数组 `[1,3,5]` 不符合要求。

如果数组 **至少** 存在一种有效划分，返回 `true` ，否则，返回 `false` 。

![2369](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2369.jpg)

```java
class Solution {
    public boolean validPartition(int[] nums) {
        /**
        f[i] 表示以 0-i 存在有效成分
        f[i] = (f[i - 2] && two(nums[i - 2], nums[i - 1])) || (f[i - 3] && three(nums[i - 3], nums[i - 2], nums[i - 1]));
        **/
        int n = nums.length;
        boolean[] f = new boolean[n + 1];
        f[0] = true;
        for (int i = 1; i <= n; i ++) {
            if (i >= 2) {
                f[i] = f[i - 2] && validTwo(nums[i - 2], nums[i - 1]);
            }
            if (i >= 3) {
                f[i] = f[i] || (f[i - 3] && validThree(nums[i - 3], nums[i - 2], nums[i - 1]));
            }
        }
        return f[n];
    }
    boolean validTwo(int a, int b) {
        return a == b;
    }
    boolean validThree(int a, int b, int c) {
        return  (a == b && a == c) || ((b - a) == 1 && (c - b) == 1);
    }
}
```

### 2617. 网格图中最少访问的格子数

给你一个下标从 **0** 开始的 `m x n` 整数矩阵 `grid` 。你一开始的位置在 **左上角** 格子 `(0, 0)` 。

当你在格子 `(i, j)` 的时候，你可以移动到以下格子之一：

- 满足 `j < k <= grid[i][j] + j` 的格子 `(i, k)` （向右移动），或者
- 满足 `i < k <= grid[i][j] + i` 的格子 `(k, j)` （向下移动）。

请你返回到达 **右下角** 格子 `(m - 1, n - 1)` 需要经过的最少移动格子数，如果无法到达右下角格子，请你返回 `-1` 。

![2617](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2617.jpg)

**思路**

根据题目描述，我们只能向下或者向右走，因此可以直接用二重循环来计算到达每一个位置的最少步数：当遍历到位置 (i,j) 时，所有其左侧和上方位置的最少步数都已经计算完成。

当我们在位置 (i,j)时，如何计算到达该位置的最少步数呢？我们可以考虑上一步是向下还是向右走的。如果是「向下走」的，那么上一个位置应该是 (i′,j)，其中 `i′<i`。除此之外，i′还需要满足下面两个要求：

- (i′,j) 要能走到 (i,j)；
- 到达 (i′,j)的步数要最少。
对于第二个要求，我们可以想到使用优先队列（小根堆）来维护所有的 i′，堆顶对应着步数最少的位置。同时对于第一个要求，我们可以在获取堆顶的 iopt′时进行判断，如果 (iopt′,j)不满足一步到达 (i,j)的要求，就可以将它从优先队列中直接移除，因为之后遍历到的同一列的位置，i的值只会更大，也就更不可能一步走到。如果优先队列中的所有元素均被移除，说明无法走到 (i,j)，否则就可以得到最少的步数，并将 i放入优先队列。

这样一来，我们需要对每一列都维护一个优先队列。第 j个优先队列存储的是所有位于第 j列的位置，其中的元素是一个二元组，第一个值是到达 (i′,j)的最少步数，作为比较的关键字；第二个值是 i′，用来判断是否可以一步到达。

同理，我们对于每一行也维护一个优先队列，这样就可以处理「向右走」的情况了。

```java
class Solution {
    public int minimumVisitedCells(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[][] dist = new int[m][n];
        for (int i = 0; i < m; i ++) {
            Arrays.fill(dist[i], -1);
        }
        dist[0][0] = 1;
        PriorityQueue<int[]>[] row =  new PriorityQueue[m];
        PriorityQueue<int[]>[] col = new PriorityQueue[n];
        for (int i = 0; i < m; i ++) {
            row[i] = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);
        }
        for (int i = 0; i < n; i ++) {
            col[i] = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);
        }

        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j ++) {
                while (!row[i].isEmpty() && row[i].peek()[1] + grid[i][row[i].peek()[1]] < j) {
                    row[i].poll();
                }
                if (!row[i].isEmpty()) {
                    dist[i][j] = update(dist[i][j], dist[i][row[i].peek()[1]] + 1);
                }

                while (!col[j].isEmpty() && col[j].peek()[1] + grid[col[j].peek()[1]][j] < i) {
                    col[j].poll();
                }
                if (!col[j].isEmpty()) {
                    dist[i][j] = update(dist[i][j], dist[col[j].peek()[1]][j] + 1);
                }

                if (dist[i][j] != -1) {
                    row[i].offer(new int[]{dist[i][j], j});
                    col[j].offer(new int[]{dist[i][j], i});
                }
            }
        }
        return dist[m - 1][n - 1];
    }
    int update(int x, int y) {
        return x == -1 || y < x ? y : x;
    }
}
```

### 2684. 矩阵中移动的最大次数

给你一个下标从 **0** 开始、大小为 `m x n` 的矩阵 `grid` ，矩阵由若干 **正** 整数组成。

你可以从矩阵第一列中的 **任一** 单元格出发，按以下方式遍历 `grid` ：

- 从单元格 `(row, col)` 可以移动到 `(row - 1, col + 1)`、`(row, col + 1)` 和 `(row + 1, col + 1)` 三个单元格中任一满足值 **严格** 大于当前单元格的单元格。

返回你在矩阵中能够 **移动** 的 **最大** 次数。

![2684](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2684.jpg)

```java
// 超出内存限制
class Solution {
    int[][] dir = new int[][]{{-1, 1}, {0, 1}, {1, 1}};
    public int maxMoves(int[][] grid) {
        int res = 0;
        for (int i = 0; i < grid.length; i ++) {
            res = Math.max(res, getMovesCnt(i, 0, grid, dp));
        }
        return res;
    }
    int getMovesCnt(int x, int y, int[][] grid) {
        int n = grid.length, m = grid[0].length;
        int cnt = 0;
        Deque<int[]> q = new ArrayDeque<>(), p = new ArrayDeque<>();
        q.offerLast(new int[]{x, y});
        while (!q.isEmpty()) {
            var cur = q.pollFirst();
            for (int i = 0; i < 3; i ++) {
                int xx = cur[0] + dir[i][0], yy = cur[1] + dir[i][1];
                if (xx >= 0 && xx < n && yy >= 0 && yy < m && grid[cur[0]][cur[1]] < grid[xx][yy]) {
                    p.offerLast(new int[]{xx, yy});
                }
            }
            if (q.isEmpty() && !p.isEmpty()) {
                q = p;
                p = new ArrayDeque<>();
                cnt ++;
            }
        }
        return cnt;
    }
}

// 正解
class Solution {
    public int maxMoves(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        Set<Integer> q = new HashSet<>();
        for (int i = 0; i < m; i++) {
            q.add(i);
        }
        for (int j = 1; j < n; j++) {
            Set<Integer> q2 = new HashSet<>();
            for (int i : q) {
                for (int i2 = i - 1; i2 <= i + 1; i2++) {
                    if (0 <= i2 && i2 < m && grid[i][j - 1] < grid[i2][j]) {
                        q2.add(i2);
                    }
                }
            }
            q = q2;
            if (q.isEmpty()) {
                return j - 1;
            }
        }
        return n - 1;
    }
}
```

### 2707. 字符串中的额外字符

给你一个下标从 **0** 开始的字符串 `s` 和一个单词字典 `dictionary` 。你需要将 `s` 分割成若干个 **互不重叠** 的子字符串，每个子字符串都在 `dictionary` 中出现过。`s` 中可能会有一些 **额外的字符** 不在任何子字符串中。

请你采取最优策略分割 `s` ，使剩下的字符 **最少** 。

![2707](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2707.jpg)

```java
class Solution {
    public int minExtraChar(String s, String[] dictionary) {
        var set = new HashSet<String>();
        for (var str : dictionary) set.add(str);
        int n = s.length();
        var f = new int[n + 1];
        for (int i = 0; i < n; i++) {
            f[i + 1] = f[i] + 1; // 不选
            for (int j = 0; j <= i; j++) { // 枚举选哪个
                if (set.contains(s.substring(j, i + 1))) {
                    f[i + 1] = Math.min(f[i + 1], f[j]);
                }
            }
        }
        return f[n];
    }
}
```

### 2919. 使数组变美的最小增量运算数

给你一个下标从 **0** 开始、长度为 `n` 的整数数组 `nums` ，和一个整数 `k` 。

你可以执行下述 **递增** 运算 **任意** 次（可以是 **0** 次）：

- 从范围 `[0, n - 1]` 中选则一个下标 `i` ，并将 `nums[i]` 的值加 `1` 。

如果数组中任何长度 **大于或等于 3** 的子数组，其 **最大** 元素都大于或等于 `k` ，则认为数组是一个 **美丽数组** 。

以整数形式返回使数组变为 **美丽数组** 需要执行的 **最小** 递增运算数。

子数组是数组中的一个连续 **非空** 元素序列。

![2919](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2919.jpg)

**思路**
定义 `dfs(i，j)`表示现在要处理 `nums[0]`到`nums[i]`这段子数组并且` nums[i]`右边有 j 个没有变大的数
选:`dfs(i, j)=dfs(i-1，0) +max (k-nums[i], 0)`不选（当 j<2 的时候）:`dfs(i, j) = dfs(i-1，j+1)`
递归边界:当`i < 0`的时候，返回 0
递归入口:`dfs(n-1，0)`

```java
class Solution {
    public long minIncrementOperations(int[] nums, int k) {
        int n = nums.length;
        long[][] g = new long[n][3];
        for (long[] arr : g) {
            Arrays.fill(arr, -1);
        }
        // 记忆化搜索
        return dfs(n - 1, 0, g, nums, k);
    }
    long dfs(int i, int j, long[][] g, int[] nums, int k) {
        if (i < 0) {
            return 0;
        }
        if (g[i][j] != -1) {
            return g[i][j];
        }
        long res = dfs(i - 1, 0, g, nums, k) + Math.max(k - nums[i], 0); // 选 i
        if (j < 2) {
            res = Math.min(res, dfs(i - 1, j + 1, g, nums, k)); // 不选 i
        }
        return g[i][j] = res;
    }
}
```

## 离散

### 1851. 包含每个查询的最小区间

给你一个二维整数数组 intervals ，其中 `intervals[i] = [lefti, righti]` 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 `righti - lefti + 1` 。

再给你一个整数数组 queries 。第 j 个查询的答案是满足 `lefti <= queries[j] <= righti` 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。

以数组形式返回对应查询的所有答案。

![包含每个查询的最小区间](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1851.jpg)

```java
class Solution {
    public int[] minInterval(int[][] intervals, int[] queries) {
        Integer[] qindex = new Integer[queries.length];
        for (int i = 0; i < queries.length; i ++) {
            qindex[i] = i;
        }
        Arrays.sort(qindex, (i, j) -> queries[i] - queries[j]);
        Arrays.sort(intervals, (i1, i2) -> i1[0] - i2[0]);
        PriorityQueue<int[]> pq = new PriorityQueue<>((p1, p2) -> p1[0] - p2[0]);
        int[] res = new int[queries.length];
        Arrays.fill(res, -1);
        int i = 0;
        for (int qi : qindex) {
            while (i < intervals.length && intervals[i][0] <= queries[qi]) {
                pq.offer(new int[]{intervals[i][1] - intervals[i][0] + 1, intervals[i][0], intervals[i][1]});
                i ++;
            }
            while (!pq.isEmpty() && pq.peek()[2] < queries[qi]) {
                pq.poll();
            }
            if (!pq.isEmpty()) {
                res[qi] = pq.peek()[0];
            }
        }
        return res;
    }
}
```

## 树

### 102. 二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![102](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/102.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        List<Integer> path = new ArrayList<>();
        Deque<TreeNode> q = new ArrayDeque<>(), p = new ArrayDeque<>();
        q.offerLast(root);
        while (!q.isEmpty()) {
            var cur = q.pollFirst();
            path.add(cur.val);
            if (cur.left != null) {
                p.offerLast(cur.left);
            }
            if (cur.right != null) {
                p.offerLast(cur.right);
            }
            if (q.isEmpty()) {
                q = p;
                p = new ArrayDeque<>();
                ans.add(path);
                path = new ArrayList<>();
            }
        }
        return ans;
    }
}
```

### 114. 二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。
- ![114](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/114.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        while (root != null) {
            if (root.left == null) {
                root = root.right;
            } else {
                TreeNode pre = root.left;
                while (pre.right != null) {
                    pre = pre.right;
                }
                pre.right = root.right;
                root.right = root.left;
                root.left = null;
                root = root.right;
            }
        }
    }
}
```

### 236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

![236. 二叉树的最近公共祖先](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/236.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == root || q == root) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if (left == null) {
            return right;
        }
        if (right == null) {
            return left;
        }
        return root;
    }
}
```

### 617. 合并二叉树

给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

> 注意: 合并过程必须从两个树的根节点开始。

![617](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/617.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }
        var cur = new TreeNode(root1.val + root2.val);
        cur.left = mergeTrees(root1.left, root2.left);
        cur.right = mergeTrees(root1.right, root2.right);
        return cur;
    }
}
```

### 889. 根据前序和后序遍历构造二叉树

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

![889](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/889.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int[] pres, posts;
    Map<Integer, Integer> map = new HashMap<>();
    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        pres = preorder;
        posts = postorder;
        int n = preorder.length;
        for (int i = 0; i < n; i ++) {
            map.put(postorder[i], i);
        }
        return dfs(0, n - 1, 0, n - 1);
    }
    TreeNode dfs(int a, int b, int x, int y) {
        if (a > b) return null;
        TreeNode cur = new TreeNode(pres[a]);
        if (a == b) return cur;
        int k = map.get(pres[a + 1]);
        cur.left = dfs(a + 1, a + 1 + k - x, x, k);
        cur.right = dfs(a + 1 + k - x + 1, b, k + 1, y - 1);
        return cur;
    }
}
```

### 894. 所有可能的真二叉树

给你一个整数 `n` ，请你找出所有可能含 `n` 个节点的 **真二叉树** ，并以列表形式返回。答案中每棵树的每个节点都必须符合 `Node.val == 0` 。

答案的每个元素都是一棵真二叉树的根节点。你可以按 **任意顺序** 返回最终的真二叉树列表****。

**真二叉树** 是一类二叉树，树中每个节点恰好有 `0` 或 `2` 个子节点。

![894](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/894.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<TreeNode> allPossibleFBT(int n) {
        List<TreeNode> res = new ArrayList<>();
        if (n % 2 == 0) return res;
        if (n == 1) res.add(new TreeNode());
        for (int i = 1; i + 1 < n; i += 2) {
            List<TreeNode> left = allPossibleFBT(i), right = allPossibleFBT(n - i - 1);
            for (TreeNode l : left) {
                for (TreeNode r : right) {
                    res.add(new TreeNode(0, l, r));
                }
            }
        }
        return res;
    }
}
```

### 993. 二叉树的堂兄弟节点

在二叉树中，根节点位于深度 `0` 处，每个深度为 `k` 的节点的子节点位于深度 `k+1` 处。

如果二叉树的两个节点深度相同，但 **父节点不同** ，则它们是一对*堂兄弟节点*。

我们给出了具有唯一值的二叉树的根节点 `root` ，以及树中两个不同节点的值 `x` 和 `y` 。

只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true` 。否则，返回 `false`。

![993](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/993.jpg)

**BFS**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        Deque<TreeNode[]> q = new ArrayDeque<>();
        q.offer(new TreeNode[]{root, null});
        int d1 = 0, d2 = 0, depth = 0;
        TreeNode p1 = null, p2 = null;
        while (!q.isEmpty()) {
            int size = q.size();
            while (size -- > 0) {
                TreeNode[] t = q.poll();
                TreeNode node = t[0], parent = t[1];
                if (node.val == x) {
                    d1 = depth;
                    p1 = parent;
                } else if (node.val == y) {
                    d2 = depth;
                    p2 = parent;
                }
                if (node.left != null) {
                    q.offer(new TreeNode[]{node.left, node});
                }
                if (node.right != null) {
                    q.offer(new TreeNode[]{node.right, node});
                }
            }
            depth ++;
        }
        return p1 != p2 && d1 == d2;
    }
}
```

**DFS**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int xx, yy, d1, d2;
    TreeNode p1, p2;
    public boolean isCousins(TreeNode root, int x, int y) {
        xx = x; yy = y;
        dfs(root, null, 0);
        return p1 != p2 && d1 == d2;
    }
    void dfs(TreeNode root, TreeNode parent, int depth) {
        if (root == null) {
            return;
        }
        if (root.val == xx) {
            d1 = depth;
            p1 = parent;
        } else if (root.val == yy) {
            d2 = depth;
            p2 = parent;
        }
        dfs(root.left, root, depth + 1);
        dfs(root.right, root, depth + 1);
    }
}
```

### 1123. 最深叶节点的最近公共祖先

给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。

回想一下：

- 叶节点 是二叉树中没有子节点的节点
- 树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1
- 如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。

![1123](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1123.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode lcaDeepestLeaves(TreeNode root) {
        return dfs(root).getKey();
    }
    Pair<TreeNode, Integer> dfs(TreeNode root) {
        if (root == null) {
            return new Pair<>(root, 0);
        }
        var left = dfs(root.left);
        var right = dfs(root.right);
        if (left.getValue() > right.getValue()) {
            return new Pair<>(left.getKey(), left.getValue() + 1);
        }
        if (left.getValue() < right.getValue()) {
            return new Pair<>(right.getKey(), right.getValue() + 1);
        }
        return new Pair<>(root, left.getValue() + 1);
    }
}
```

### 1261. 在受污染的二叉树中查找元素

给出一个满足下述规则的二叉树：

1. `root.val == 0`
2. 如果 `treeNode.val == x` 且 `treeNode.left != null`，那么 `treeNode.left.val == 2 * x + 1`
3. 如果 `treeNode.val == x` 且 `treeNode.right != null`，那么 `treeNode.right.val == 2 * x + 2`

现在这个二叉树受到「污染」，所有的 `treeNode.val` 都变成了 `-1`。

请你先还原二叉树，然后实现 `FindElements` 类：

- `FindElements(TreeNode* root)` 用受污染的二叉树初始化对象，你需要先把它还原。
- `bool find(int target)` 判断目标值 `target` 是否存在于还原后的二叉树中并返回结果。

![1261](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1261.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class FindElements {
    Set<Integer> vals = new HashSet<>();
    public FindElements(TreeNode root) {
        root.val = 0;
        vals.add(0);
        dfs(root);
    }
    void dfs(TreeNode root) {
        if (root != null) {
            if (root.left != null) {
                root.left.val = 2 * root.val + 1;
            }
            if (root.right != null) {
                root.right.val = 2 * root.val + 2;
            }
            vals.add(root.val);
            dfs(root.left);
            dfs(root.right);
        }
    }
    public boolean find(int target) {
        return vals.contains(target);
    }
}

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements obj = new FindElements(root);
 * boolean param_1 = obj.find(target);
 */
 ```

### 1448. 统计二叉树中好节点的数目

给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。

「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。

![1448. 统计二叉树中好节点的数目](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1448.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int goodNodes(TreeNode root) {
        int res = dfs(root, Integer.MIN_VALUE);
        return res;
    }
    int dfs(TreeNode root, int val) {
        if (root != null) {
            val = Math.max(val, root.val);
            return dfs(root.left, val)  + dfs(root.right, val) + (root.val >= val ? 1 : 0);
        }
        return 0;
    }
}
```

### 1457. 二叉树中的伪回文路径

给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「**伪回文**」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。

请你返回从根到叶子节点的所有路径中 **伪回文** 路径的数目。

![1457](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1457.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int pseudoPalindromicPaths (TreeNode root) {
        return dfs(root, 0);
    }
    int dfs(TreeNode root, int mask) {
        if (root == null) {
            return 0;
        }
        mask ^= 1 << root.val;
        if (root.left == null && root.right == null) {
            /**
             * 如果 mask 中只有一个 1，那么去掉这个 1 之后，mask 就变成 0 了
             * 可以通过 mask&(mask−1) 「删除最小元素」的方法，判断 mask&(mask−1)==0
             */
            return (mask & (mask - 1)) == 0 ? 1 : 0;
        }
        return dfs(root.left, mask) + dfs(root.right, mask);
    }
}
```

### 2368. 受限条件下可到达节点的数目

现有一棵由 `n` 个节点组成的无向树，节点编号从 `0` 到 `n - 1` ，共有 `n - 1` 条边。

给你一个二维整数数组 `edges` ，长度为 `n - 1` ，其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间存在一条边。另给你一个整数数组 `restricted` 表示 **受限** 节点。

在不访问受限节点的前提下，返回你可以从节点 `0` 到达的 **最多** 节点数目*。*

注意，节点 `0` **不** 会标记为受限节点。

![2368](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2368.jpg)

```java
class Solution {
    public int reachableNodes(int n, int[][] edges, int[] restricted) {
        int ans = 1;
        boolean[] flag = new boolean[n];
        for (int x : restricted) {
            flag[x] = true;
        }

        List<Integer>[] g = new ArrayList[n];
        for (int i = 0; i < n; i ++) {
            g[i] = new ArrayList<>();
        }

        for (int[] e : edges) {
            int a = e[0], b = e[1];
            g[a].add(b);
            g[b].add(a);
        }
        
        Queue<Integer> q = new ArrayDeque<>();
        q.offer(0);
        
        while (!q.isEmpty()) {
            int cur = q.poll();
            flag[cur] = true;
            for (int x : g[cur]) {
                if (!flag[x]) {
                    q.offer(x);
                    ans ++;
                }
            }
        }
        return ans;
    }
}
```

### 2415. 反转二叉树的奇数层

给你一棵 **完美** 二叉树的根节点 `root` ，请你反转这棵树中每个 **奇数** 层的节点值。

- 例如，假设第 3 层的节点值是 `[2,1,3,4,7,11,29,18]` ，那么反转后它应该变成 `[18,29,11,7,4,3,1,2]` 。

反转后，返回树的根节点。

**完美** 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。

节点的 **层数** 等于该节点到根节点之间的边数。

![2415](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2415.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode reverseOddLevels(TreeNode root) {
        dfs(root.left, root.right, true);
        return root;
    }
    void dfs(TreeNode l, TreeNode r, boolean isOdd) {
        if (l == null) return;
        if (isOdd) {
            int tmp = l.val;
            l.val = r.val;
            r.val = tmp;
        }
        dfs(l.left, r.right, !isOdd);
        dfs(l.right, r.left, !isOdd);
    }
}
```

### 2476. 二叉搜索树最近节点查询

给你一个 **二叉搜索树** 的根节点 `root` ，和一个由正整数组成、长度为 `n` 的数组 `queries` 。

请你找出一个长度为 `n` 的 **二维** 答案数组 `answer` ，其中 `answer[i] = [mini, maxi]` ：

- `mini` 是树中小于等于 `queries[i]` 的 **最大值** 。如果不存在这样的值，则使用 `-1` 代替。
- `maxi` 是树中大于等于 `queries[i]` 的 **最小值** 。如果不存在这样的值，则使用 `-1` 代替。

返回数组 `answer` 。

![2476](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2476.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {
        List<Integer> arr = new ArrayList<>();
        dfs(root, arr);
        List<List<Integer>> ans = new ArrayList<>();
        for (int x : queries) {
            int l = 0, r = arr.size();
            while (l < r) {
                int mid = l + r >> 1;
                if (arr.get(mid) < x) {
                    l = mid + 1;
                } else {
                    r = mid;
                }
            }
            int mx = r == arr.size() ? -1 : arr.get(r);
            if (r == arr.size() || arr.get(r) != x) {
                r --;
            }
            int mn = r < 0 ? -1 : arr.get(r);
            ans.add(List.of(mn, mx));
        }
        return ans;
    }
    void dfs(TreeNode root, List<Integer> arr) {
        if (root != null) {
            dfs(root.left, arr);
            arr.add(root.val);
            dfs(root.right, arr);
        }
    }
}
```

### 2583. 二叉树中的第 K 大层和

给你一棵二叉树的根节点 `root` 和一个正整数 `k` 。

树中的 **层和** 是指 **同一层** 上节点值的总和。

返回树中第 `k` 大的层和（不一定不同）。如果树少于 `k` 层，则返回 `-1` 。

**注意**，如果两个节点与根节点的距离相同，则认为它们在同一层。

![2583](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2583.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public long kthLargestLevelSum(TreeNode root, int k) {
        Deque<TreeNode> q = new ArrayDeque<>(), p = new ArrayDeque<>();
        List<Long> arr = new ArrayList<Long>();
        q.offerLast(root);
        long sum = 0;
        while (!q.isEmpty()) {
            var cur = q.pollFirst();
            sum += cur.val;
            if (cur.left != null) {
                p.offerLast(cur.left);
            }
            if (cur.right != null) {
                p.offerLast(cur.right);
            }
            if (q.isEmpty()) {
                q = p;
                arr.add(sum);
                sum = 0;
                p = new ArrayDeque<>();
            }
        }
        if (arr.size() < k) {
            return -1;
        }
        Collections.sort(arr);
        return arr.get(arr.size() - k);
    }
}
```

### 2641. 二叉树的堂兄弟节点 II

给你一棵二叉树的根 `root` ，请你将每个节点的值替换成该节点的所有 **堂兄弟节点值的和** 。

如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 **堂兄弟** 。

请你返回修改值之后，树的根 `root` 。

> 一个节点的深度指的是从树根节点到这个节点经过的边数。

![2641](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2641.jpg)

**方法一：两次 DFS**

我们创建一个列表 `s` 用于记录二叉树每一层的节点值之和，其中 `s[depth]` 表示第 `depth` 层的节点值之和（规定根节点所在的层为第 0 层）。

接下来，我们先跑一遍 DFS，计算出数组 `s` 的值。然后再跑一遍 DFS，更新每个节点的子节点的值，子节点的值等于子节点所在层的节点值之和减去子节点及其兄弟节点的值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> s = new ArrayList<>();

    public TreeNode replaceValueInTree(TreeNode root) {
        dfs1(root, 0);
        root.val = 0;
        dfs2(root, 0);
        return root;
    }
    void dfs1(TreeNode root, int depth) {
        if (root == null) {
            return;
        }
        if (s.size() <= depth) {
            s.add(0);
        }
        s.set(depth, s.get(depth) + root.val);
        dfs1(root.left, depth + 1);
        dfs1(root.right, depth + 1);
    }
    void dfs2(TreeNode root, int depth) {
        int l = root.left == null ? 0 : root.left.val;
        int r = root.right == null ? 0 : root.right.val;
        int sub = l + r;
        depth ++;
        if (root.left != null) {
            root.left.val = s.get(depth) - sub;
            dfs2(root.left, depth);
        }
        if (root.right != null) {
            root.right.val = s.get(depth) - sub;
            dfs2(root.right, depth);
        }
    }
}
```

**方法二：BFS**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode replaceValueInTree(TreeNode root) {
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        int sum = root.val;
        while (!queue.isEmpty()) {
            int size = queue.size();
            int nextSum = 0;
            while (size-- > 0) {
                TreeNode node = queue.poll();
                node.val = sum - node.val; // node.val == 它与兄弟结点值的和
                if (node.left != null && node.right != null) {
                    nextSum += node.left.val + node.right.val;
                    node.left.val += node.right.val; // 将左右子节点的值都改为它们的和
                    node.right.val = node.left.val;
                    queue.offer(node.left);
                    queue.offer(node.right);
                } else if (node.right != null) {
                    nextSum += node.right.val;
                    queue.offer(node.right);
                } else if (node.left != null) {
                    nextSum += node.left.val;
                    queue.offer(node.left);
                }
            }
            sum = nextSum;
        }
        return root;
    }
}
```

## 图

### 1334. 阈值距离内邻居最少的城市

有 `n` 个城市，按从 `0` 到 `n-1` 编号。给你一个边数组 `edges`，其中 `edges[i] = [fromi, toi, weighti]` 代表 `fromi` 和 `toi` 两个城市之间的双向加权边，距离阈值是一个整数 `distanceThreshold`。

返回能通过某些路径到达其他城市数目最少、且路径距离 **最大** 为 `distanceThreshold` 的城市。如果有多个这样的城市，则返回编号最大的城市。

注意，连接城市 **_i_** 和 **_j_** 的路径的距离等于沿该路径的所有边的权重之和。

![1334](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1334.jpg)

```java
class Solution {
    public int findTheCity(int n, int[][] edges, int distanceThreshold) {
        int[][] g = new int[n][n];
        for (int i = 0; i < n; i ++) {
            Arrays.fill(g[i], Integer.MAX_VALUE / 2);
        }
        for (int[] edge : edges) {
            int a = edge[0], b = edge[1], c = edge[2];
            g[a][b] = g[b][a] = c;
        }
        for (int k = 0; k < n; k ++) {
            g[k][k] = 0;
            for (int i = 0; i < n; i ++) {
                for (int j = 0; j < n; j ++) {
                    g[i][j] = Math.min(g[i][j], g[i][k] + g[k][j]);
                }
            }
        }
        int[] ans = {Integer.MAX_VALUE / 2, -1};
        for (int i = 0; i < n; i ++) {
            int cnt = 0;
            for (int j = 0; j < n; j ++) {
                if (g[i][j] <= distanceThreshold) {
                    cnt ++;
                }
            }
            if (cnt <= ans[0]) {
                ans[1] = i;
                ans[0] = cnt;
            }
        }
        return ans[1];
    }
}
```

### 1462. 课程表 IV

你总共需要上 numCourses 门课，课程编号依次为 0 到 numCourses-1 。你会得到一个数组 prerequisite ，其中 `prerequisites[i] = [ai, bi]` 表示如果你想选 bi 课程，你 必须 先选 ai 课程。

- 有的课会有直接的先修课程，比如如果想上课程 1 ，你必须先上课程 0 ，那么会以 [0,1] 数对的形式给出先修课程数对。
  先决条件也可以是 间接 的。如果课程 a 是课程 b 的先决条件，课程 b 是课程 c 的先决条件，那么课程 a 就是课程 c 的先决条件。

你也得到一个数组 queries ，其中 `queries[j] = [uj, vj]`。对于第 j 个查询，您应该回答课程 uj 是否是课程 vj 的先决条件。

返回一个布尔数组 answer ，其中 answer[j] 是第 j 个查询的答案。

![1462. 课程表 IV](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1462.jpg)

```java
class Solution {
    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {
      Map<Integer, Set<Integer>> g = new HashMap<>();
      int[] d = new int[numCourses];
      for (int i = 0; i < numCourses; i ++) {
        g.put(i, new HashSet<>());
      }
      for (int[] p : prerequisites) {
        int a = p[0], b = p[1];
        g.get(a).add(b);
        d[b] ++;
      }
      Queue<Integer> queue = new LinkedList<>();
      int tail = 0;
      for (int i = 0; i < numCourses; i ++) {
        if (d[i] == 0) {
          queue.offer(i);
          tail = i;
        }
      }
      boolean[][] isPre = new boolean[numCourses][numCourses];
      while (!queue.isEmpty()) {
        int cur = queue.poll();
        for (int next : g.get(cur)) {
          isPre[cur][next] = true;
          for (int i = 0; i < numCourses; i ++) {
            isPre[i][next] = isPre[i][cur] | isPre[i][next];
          }
          d[next] --;
          if (d[next] == 0) {
            queue.offer(next);
          }
        }
      }
      List<Boolean> ans = new ArrayList<>();
      for (int i = 0; i < queries.length; i ++) {
        int a = queries[i][0], b = queries[i][1];
        ans.add(isPre[a][b]);
      }
      return ans;
    }
}
```

### 2642. 设计可以求最短路径的图类

给你一个有 `n` 个节点的 **有向带权** 图，节点编号为 `0` 到 `n - 1` 。图中的初始边用数组 `edges` 表示，其中 `edges[i] = [fromi, toi, edgeCosti]` 表示从 `fromi` 到 `toi` 有一条代价为 `edgeCosti` 的边。

请你实现一个 `Graph` 类：

- `Graph(int n, int[][] edges)` 初始化图有 `n` 个节点，并输入初始边。
- `addEdge(int[] edge)` 向边集中添加一条边，其中 `edge = [from, to, edgeCost]` 。数据保证添加这条边之前对应的两个节点之间没有有向边。
- `int shortestPath(int node1, int node2)` 返回从节点 `node1` 到 `node2` 的路径 **最小** 代价。如果路径不存在，返回 `-1` 。一条路径的代价是路径中所有边代价之和。

![2642](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2642.jpg)

**邻接矩阵建图 + 朴素 `Dijkstra`

```java
class Graph {
    final int INF = Integer.MAX_VALUE / 2;
    final int[][] g;
    public Graph(int n, int[][] edges) {
        g = new int[n][n];
        for (int i = 0; i < n; i ++) {
            Arrays.fill(g[i], INF);
        }
        for (int[] edge : edges) {
            addEdge(edge);
        }
    }
    
    public void addEdge(int[] edge) {
        int a = edge[0], b = edge[1], c = edge[2];
        g[a][b] = c;
    }
    
    public int shortestPath(int node1, int node2) {
        int n = g.length;
        int[] dist = new int[n];
        Arrays.fill(dist, INF);
        boolean[] st = new boolean[n];
        dist[node1] = 0;
        for (int i = 0; i < n; i ++) {
            int t = -1;
            for (int j = 0; j < n; j ++) {
                if (!st[j] && (t == -1 || dist[t] > dist[j])) {
                    t = j;
                }
            }
            if (t == -1 || dist[t] == INF) {
                return -1;
            }
            if (t == node2) {
                return dist[t];
            }
            st[t] = true;
            for (int j = 0; j < n; j ++) {
                dist[j] = Math.min(dist[j], dist[t] + g[t][j]);
            }
        }
        return -1;
    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * Graph obj = new Graph(n, edges);
 * obj.addEdge(edge);
 * int param_2 = obj.shortestPath(node1,node2);
 */
```

**复杂度分析**

时间复杂度：
1. 初始化 O(n2)。
2. addEdge O(1)。
3. shortestPath O(n2)。
空间复杂度：O(n2)。


**邻接表建图 + 堆优化 `Dijkstra`

```java
class Graph {
    List<int[]>[] g;
    public Graph(int n, int[][] edges) {
        g = new ArrayList[n];
        for (int i = 0; i < n; i ++) {
            g[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            addEdge(edge);
        }
    }
    
    public void addEdge(int[] edge) {
        int a = edge[0], b = edge[1], c = edge[2];
        g[a].add(new int[]{b, c});
    }
    
    public int shortestPath(int node1, int node2) {
        int[] dis = new int[g.length];
        Arrays.fill(dis, Integer.MAX_VALUE);
        dis[node1] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, node1});
        while (!pq.isEmpty()) {
            int[] p = pq.poll();
            int d = p[0], t = p[1];
            if (t == node2) {
                return d;
            }
            if (d > dis[t]) {
                continue;
            }
            for (int[] e : g[t]) {
                int x = e[0], y = e[1];
                if (d + y < dis[x]) {
                    dis[x] = d + y;
                    pq.offer(new int[]{dis[x], x});
                }
            }
        }
        return -1;
    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * Graph obj = new Graph(n, edges);
 * obj.addEdge(edge);
 * int param_2 = obj.shortestPath(node1,node2);
 */
```

**复杂度分析**

时间复杂度：
1. 初始化 O(n+m)。其中 m 为 edges的长度。
2. addEdge O(1)。
3. shortestPath O(n+mlogm)。其中 m 为调用 shortestPath时，图的边数。当图是稠密图时，复杂度为 O(n2log⁡n)。
空间复杂度：O(n+m)。其中 m 为 edges的长度加上 addEdge的调用次数。

## 堆

### 2034. 股票价格波动

给你一支股票价格的数据流。数据流中每一条记录包含一个 **时间戳** 和该时间点股票对应的 **价格** 。

不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 **更正** 前一条错误的记录。

请你设计一个算法，实现：

- **更新** 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 **更正** 之前的错误价格。
- 找到当前记录里 **最新股票价格** **。最新股票价格** 定义为时间戳最晚的股票价格。
- 找到当前记录里股票的 **最高价格** 。
- 找到当前记录里股票的 **最低价格** 。

请你实现 `StockPrice` 类：

- `StockPrice()` 初始化对象，当前无股票价格记录。
- `void update(int timestamp, int price)` 在时间点 `timestamp` 更新股票价格为 `price` 。
- `int current()` 返回股票 **最新价格** 。
- `int maximum()` 返回股票 **最高价格** 。
- `int minimum()` 返回股票 **最低价格** 。

![2034](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2034.jpg)

```java
class StockPrice {
    int maxTime;
    Map<Integer, Integer> map;
    PriorityQueue<int[]> minHeap, maxHeap;

    public StockPrice() {
        maxTime = 0;
        map = new HashMap<>();
        minHeap = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        maxHeap = new PriorityQueue<>((a, b) -> b[1] - a[1]);
    }

    public void update(int timestamp, int price) {
        maxTime = Math.max(timestamp, maxTime);
        map.put(timestamp, price);
        minHeap.offer(new int[]{timestamp, price});
        maxHeap.offer(new int[]{timestamp, price});
    }

    public int current() {
        return map.get(maxTime);
    }

    public int maximum() {
        while (true) {
            int[] cur = maxHeap.peek();
            if (map.get(cur[0]) == cur[1]) {
                return cur[1];
            }
            maxHeap.poll();
        }
    }

    public int minimum() {
        while (true) {
            int[] cur = minHeap.peek();
            if (map.get(cur[0]) == cur[1]) {
                return cur[1];
            }
            minHeap.poll();
        }
    }
}

/**
 * Your StockPrice object will be instantiated and called as such:
 * StockPrice obj = new StockPrice();
 * obj.update(timestamp,price);
 * int param_2 = obj.current();
 * int param_3 = obj.maximum();
 * int param_4 = obj.minimum();
 */
```

## 回溯

### 2698. 求一个整数的惩罚数

给你一个正整数 `n` ，请你返回 `n` 的 **惩罚数** 。

`n` 的 **惩罚数** 定义为所有满足以下条件 `i` 的数的平方和：

- `1 <= i <= n`
- `i * i` 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 `i` 。

![2698](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2698.jpg)

```java
class Solution {
    public int punishmentNumber(int n) {
        int res = 0;
        for (int i = 1; i <= n; i ++) {
            String s = Integer.toString(i * i);
            if (dfs(s, 0, 0, i)) {
                res += i * i;
            }
        }
        return res;
    }
    boolean dfs(String s, int u, int x, int k) {
        if (u == s.length()) {
            return x == k;
        }
        int sum = 0;
        for (int i = u; i < s.length(); i ++) {
            sum = sum * 10 + s.charAt(i) - '0';
            if (sum + x > k) {
                break;
            }
            if (dfs(s, i + 1, sum + x, k)) {
                return true;
            }
        }
        return false;
    }

}
```

### 2850. 将石头分散到网格图的最少移动次数

给你一个大小为 `3 * 3` ，下标从 **0** 开始的二维整数矩阵 `grid` ，分别表示每一个格子里石头的数目。网格图中总共恰好有 `9` 个石头，一个格子里可能会有 **多个** 石头。

每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。

请你返回每个格子恰好有一个石头的 **最少移动次数** 。

![2850](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2850.jpg)

```java
class Solution {
    public int minimumMoves(int[][] grid) {
        List<int[]> from = new ArrayList<>();
        List<int[]> to = new ArrayList<>();
        for (int i = 0; i < 3; i ++) {
            for (int j = 0; j < 3; j ++) {
                int x = grid[i][j];
                if (x == 0) {
                    to.add(new int[]{i, j});
                } else if (x > 1) {
                    for (int k = 1; k < x; k ++) {
                        from.add(new int[]{i, j});
                    }
                }
            }
        }
        int res = 100;
        for (List<int[]> premution : getPermutions(from)) {
            int total = 0;
            for (int i = 0; i < premution.size(); i ++) {
                int[] p = premution.get(i), t = to.get(i);
                total += Math.abs(p[0] - t[0]) + Math.abs(p[1] - t[1]);
            }
            res = Math.min(res, total);
        }
        return res;
    }
    List<List<int[]>> getPermutions(List<int[]> from) {
        List<List<int[]>> res = new ArrayList<>();
        dfs(from, 0, res);
        return res;
    }
    void dfs(List<int[]> arr, int u, List<List<int[]>> res) {
        if (u == arr.size()) {
            res.add(new ArrayList<>(arr));
        }
        for (int i = u; i < arr.size(); i ++) {
            swap(arr, u, i);
            dfs(arr, u + 1, res);
            swap(arr, u, i);
        }
    }
    void swap(List<int[]> arr, int i, int j) {
        int[] t = arr.get(i);
        arr.set(i, arr.get(j));
        arr.set(j, t);
    }
}
```

## 并查集

### 2316. 统计无向图中无法互相到达点对数

给你一个整数 `n` ，表示一张 **无向图** 中有 `n` 个节点，编号为 `0` 到 `n - 1` 。同时给你一个二维整数数组 `edges` ，其中 `edges[i] = [ai, bi]` 表示节点 `ai` 和 `bi` 之间有一条 **无向** 边。

请你返回 **无法互相到达** 的不同 **点对数目** 。

![2316](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2316.jpg)

**深度优先搜索**

```java
class Solution {
    public long countPairs(int n, int[][] edges) {
        List<Integer>[] g = new ArrayList[n];
        Arrays.setAll(g, e -> new ArrayList<>());
        // 建图
        for (int[] e : edges) {
            int x = e[0], y = e[1];
            g[x].add(y);
            g[y].add(x);
        }
        boolean[] vis = new boolean[n];
        long ans = 0;
        for (int i = 0, total = 0; i < n; i ++) {
            if (!vis[i]) {
                int size = dfs(i, g, vis);
                total += size;
                ans += (long) size * (n - total);
            }
        }
        return ans;
    }
    int dfs(int x, List<Integer>[] g, boolean[] vis) {
        vis[x] = true;
        int size = 1;
        for (int y : g[x]) {
            if (!vis[y]) {
                size += dfs(y, g, vis);
            }
        }
        return size;
    }
}
```

**并查集**

```java
class Solution {
    public long countPairs(int n, int[][] edges) {
        int[] f = new int[n], fsize = new int[n];
        Arrays.fill(fsize, 1);
        for (int i = 0; i < n; i ++) {
            f[i] = i;
        }
        for (int[] e : edges) {
            union(f, fsize, e[0], e[1]);
        }
        long res = 0, presum = 0;
        for (int i = 0; i < n; i ++) {
            if (fsize[i] > 0) {
                presum += fsize[i];
                res += fsize[i] * (n - presum);
            }
        }
        return res;
    }
    int find(int[] f, int i) {
        if (f[i] != i) {
            return find(f, f[i]);
        }
        return f[i];
    }
    void union(int[] f, int[] fsize, int i, int j) {
        int fi = find(f, i);
        int fj = find(f, j);
        if (fi != fj) {
            f[fi] = fj;
            // 计算每个连通块的大小
            fsize[fj] += fsize[fi];
            fsize[fi] = 0;
        }
    }
}
```

## 位运算

### 318. 最大单词长度乘积

给你一个字符串数组 `words` ，找出并返回 `length(words[i]) * length(words[j])` 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 `0` 。

![318](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/318.jpg)

```java
class Solution {
    public int maxProduct(String[] words) {
        int n = words.length;
        int[] bit = new int[n];
        for (int i = 0; i < n; i ++) {
            String s = words[i];
            for (int j = 0; j < s.length(); j ++) {
                bit[i] |= 1 << (s.charAt(j) - 'a');
            }
        }
        int res = 0;
        for (int i = 0; i < n - 1; i ++) {
            for (int j = i + 1; j < n; j ++) {
                if ((bit[i] & bit[j]) == 0) {
                    res = Math.max(res, words[i].length() * words[j].length());
                }
            }
        }
        return res;
    }
}
```

## 深度优先搜索

### 1466. 重新规划路线

`n` 座城市，从 `0` 到 `n-1` 编号，其间共有 `n-1` 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。

路线用 `connections` 表示，其中 `connections[i] = [a, b]` 表示从城市 `a` 到 `b` 的一条有向路线。

今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。

请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。

题目数据 **保证** 每个城市在重新规划路线方向后都能到达城市 0 。

![1466](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1466.jpg)

```java
class Solution {
    public int minReorder(int n, int[][] connections) {
        List<int[]>[] e = new List[n];
        for (int i = 0; i < n; i ++) {
            e[i] = new ArrayList<int[]>();
        }
        // 从 0 点出发去遍历其他点使用 1 标记原方向的边，使用 0 标记反向边
        for (int[] edge : connections) {
            e[edge[0]].add(new int[]{edge[1], 1});
            e[edge[1]].add(new int[]{edge[0], 0});
        }
        return dfs(0, -1, e);
    }
    int dfs(int x, int parent, List<int[]>[] e) {
        int res = 0;
        for (int[] edge : e[x]) {
            if (edge[0] == parent) {
                continue;
            }
            res += edge[1] + dfs(edge[0], x, e);
        }
        return res;
    }
}
```

### 2477. 到达首都的最少油耗

给你一棵 `n` 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 `0` 到 `n - 1` ，且恰好有 `n - 1` 条路。`0` 是首都。给你一个二维整数数组 `roads` ，其中 `roads[i] = [ai, bi]` ，表示城市 `ai` 和 `bi` 之间有一条 **双向路** 。

每个城市里有一个代表，他们都要去首都参加一个会议。

每座城市里有一辆车。给你一个整数 `seats` 表示每辆车里面座位的数目。

城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。

请你返回到达首都最少需要多少升汽油。

![2477](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2477.jpg)

**思路**

![2477A](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2477A.jpg)

```java
class Solution {
    long res = 0;
    public long minimumFuelCost(int[][] roads, int seats) {
        int n = roads.length;
        List<Integer>[] g = new List[n + 1];
        for (int i = 0; i <= n; i ++) {
            g[i] = new ArrayList<Integer>();
        }
        for (int[] e : roads) {
            g[e[0]].add(e[1]);
            g[e[1]].add(e[0]);
        }
        dfs(0, -1, seats, g);
        return res;
    }
    int dfs(int cur, int fa, int seats, List<Integer>[] g) {
        int sum = 1;
        for (int ne : g[cur]) {
            if (ne != fa) {
                int cnt = dfs(ne, cur, seats, g);
                sum += cnt;
                res += (cnt + seats - 1) / seats;
            }
        }
        return sum;
    }
}
```

## 广度优先搜索

### 994. 腐烂的橘子

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。

![994](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1715565119912.jpg)

```java
class Solution {
    public int orangesRotting(int[][] grid) {
        int n = grid.length, m = grid[0].length;
        int[] dx = {0, 1, -1, 0}, dy = {1, 0, 0, -1};
        Queue<int[]> q = new LinkedList<>();
        int cnt = 0;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (grid[i][j] == 2) {
                    q.offer(new int[]{i, j});
                } else if (grid[i][j] == 1) {
                    cnt ++;
                }
            }
        }
        int ans = 0;
        while (cnt > 0 && !q.isEmpty()) {
            var p = q;
            q = new LinkedList<>();
            while (!p.isEmpty()) {
                var cur = p.poll();
                for (int i = 0; i < 4; i ++) {
                    int x = cur[0] + dx[i], y = cur[1] + dy[i];
                    if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1) {
                        q.offer(new int[]{x, y});
                        grid[x][y] = 2;
                        cnt --;
                    }
                }
            }
            ans ++;
        }
        return cnt > 0 ? -1 : ans;
    }
}
```

### 1631. 最小体力消耗路径

你准备参加一场远足活动。给你一个二维 `rows x columns` 的地图 `heights` ，其中 `heights[row][col]` 表示格子 `(row, col)` 的高度。一开始你在最左上角的格子 `(0, 0)` ，且你希望去最右下角的格子 `(rows-1, columns-1)` （注意下标从 **0** 开始编号）。你每次可以往 **上****，下****，左****，右** 四个方向之一移动，你想要找到耗费 **体力** 最小的一条路径。

一条路径耗费的 **体力值** 是路径上相邻格子之间 **高度差绝对值** 的 **最大值** 决定的。

请你返回从左上角走到右下角的最小 **体力消耗值** 。

![1631](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/1631.jpg)

```java
class Solution {
    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    public int minimumEffortPath(int[][] heights) {
        int n = heights.length, m = heights[0].length;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.offer(new int[]{0, 0, 0});

        int[] dist = new int[n * m];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[0] = 0;
        boolean[] seen = new boolean[n * m];
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int x = cur[0], y = cur[1], d = cur[2];
            int id = x * m + y;
            if (seen[id]) {
                continue;
            }
            if (x == n - 1 && y == m - 1) {
                break;
            }
            seen[id] = true;
            for (int i = 0; i < 4; i ++) {
                int nx = x + dirs[i][0], ny = y + dirs[i][1];
                if (nx >= 0 && nx < n && ny >= 0 && ny < m && Math.max(d, Math.abs(heights[x][y] - heights[nx][ny])) < dist[nx * m + ny]) {
                    dist[nx * m + ny] = Math.max(d, Math.abs(heights[x][y] - heights[nx][ny]));
                    pq.offer(new int[]{nx, ny, dist[nx * m + ny]});
                }
            }
        }
        return dist[n * m - 1];
    }
}
```

**二分法**

```java
class Solution {
    public int minimumEffortPath(int[][] heights) {
        int m = heights.length;
        int n = heights[0].length;
        int lo = 0;
        int hi = 1000000;
        while (lo < hi) {
            int mid = lo/2 + hi/2;
            boolean[][] visited = new boolean[m][n];
            if (canPass(heights, visited, heights[0][0], mid, 0, 0)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    }

    private boolean canPass(int[][] heights, boolean[][] seen, int curr, int cost, int i, int j) {
        if (i < 0 || i >= seen.length || j < 0 || j >= seen[0].length) {
            return false;
        }
        if (seen[i][j] || Math.abs(heights[i][j] - curr) > cost) {
            return false;
        }
        if (i == seen.length - 1 && j == seen[0].length - 1) {
            return true;
        }
        seen[i][j] = true;
        if (canPass(heights, seen, heights[i][j], cost, i + 1, j))
            return true;
        if (canPass(heights, seen, heights[i][j], cost, i, j + 1))
            return true;
        if (canPass(heights, seen, heights[i][j], cost, i - 1, j))
            return true;
        if (canPass(heights, seen, heights[i][j], cost, i, j - 1))
            return true;
        return false;
    }
}
```

### 2258. 逃离火灾

给你一个下标从 **0** 开始大小为 `m x n` 的二维整数数组 `grid` ，它表示一个网格图。每个格子为下面 3 个值之一：

- `0` 表示草地。
- `1` 表示着火的格子。
- `2` 表示一座墙，你跟火都不能通过这个格子。

一开始你在最左上角的格子 `(0, 0)` ，你想要到达最右下角的安全屋格子 `(m - 1, n - 1)` 。每一分钟，你可以移动到 **相邻** 的草地格子。每次你移动 **之后** ，着火的格子会扩散到所有不是墙的 **相邻** 格子。

请你返回你在初始位置可以停留的 **最多** 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 `-1` 。如果不管你在初始位置停留多久，你 **总是** 能到达安全屋，请你返回 `109` 。

注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。

如果两个格子有共同边，那么它们为 **相邻** 格子。

![2258](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/2258.jpg)

**思路**

**BFS + 分类讨论**

通过比较双方到达时间来求解。

具体的，用`fg`和`pg`，分别预处理出「火势」和「人员」到达每个网格的最早时间。其中火势蔓延唯一确定，而人员的预处理是在不考虑火势的情况下进行。

根据`f=fg[n−1][m−1]f = fg[n-1][m-1]f=fg[n−1][m−1]`和`p=pg[n−1][m−1]p = pg[n-1][m-1]p=pg[n−1][m−1]`进行分情况讨论：

若 `p=0`：人与安全屋不连通，返回 `−1`；

若 `f=0`：火与安全屋不连通，同时上述条件不满足（`p≠0`），即人与安全屋是联通 ，返回 `1e9`；

若 `f<pf`： 火和人都能到达安全屋。即使不考虑人员中途被火影响（人员可能无法按照最佳路线前往安全屋）的情况下，火也比人要更早到达安全屋，返回 `−1`；

若 `f⩾pf`：理想情况下，人比火更早到达安全屋，但存在「人火同时到达」、「人员中途被烧」或「通路被火拦截」等问题，需要进一步分情况讨论：

不难发现，由于安全屋的位于 `(n−1,m−1)(n - 1, m - 1)(n−1,m−1)`，人员只能从 `(n−1,m−2)(n - 1, m - 2)(n−1,m−2) `或 `(n−2,m−1)(n - 2, m - 1)(n−2,m−1)` 两个位置之一到达安全屋（这两个属于普通位置，不允许人和火同时到达），因此可以将「对特殊位置安全屋」的讨论转为「对普通位置」的讨论：

若 `pg[n−1][m−2]≠0`，人与该位置联通，且 `f−p+pg[n−1][m−2]<fg[n−1][m−2]`，人比火更早到达该位置，返回 `f−pf`；
若 `pg[n−2][m−1]≠0`，人与该位置联通，且 `f−p+pg[n−2][m−1]<fg[n−2][m−1]`，人比火更早到达该位置，返回 `f−pf`；
否则，说明延迟 `f−pf`秒出发，唯二的通路会被火提前拦截，需要早一秒出发，返回 `f−p−1`;

```java
class Solution {
    int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    int[][] g;
    int n, m;
    public int maximumMinutes(int[][] grid) {
        g = grid;
        n = g.length;
        m = g[0].length;
        int[][] ft = new int[n][m], pt = new int[n][m];
        Queue<int[]> fires = new LinkedList<>();
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (g[i][j] == 1) {
                    ft[i][j] = 1;
                    fires.offer(new int[]{i, j});
                }
            }
        }
        dfs(fires, ft);
        Queue<int[]> people = new LinkedList<>();
        people.offer(new int[]{0, 0});
        pt[0][0] = 1;
        dfs(people, pt);
        int p = pt[n - 1][m - 1], f = ft[n - 1][m - 1], res = f - p;
        if (p == 0) return -1;
        if (f == 0) return (int)1e9;
        if (p > f) return -1;
        if (pt[n - 1][m - 2] != 0 && res + pt[n - 1][m - 2] < ft[n - 1][m - 2]) return res;
        if (pt[n - 2][m - 1] != 0 && res + pt[n - 2][m - 1] < ft[n - 2][m - 1]) return res;
        return res - 1;
    }
    void dfs(Queue<int[]> queue, int[][] time) {
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            for (int[] dir : dirs) {
                int x = cur[0] + dir[0], y = cur[1] + dir[1];
                if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] != 2 && time[x][y] == 0) {
                    time[x][y] = time[cur[0]][cur[1]] + 1;
                    queue.offer(new int[]{x, y});
                }
            }
        }
    }
}
```

## 树状数组

### 307. 区域和检索 - 数组可修改

给你一个数组 `nums` ，请你完成两类查询。

1. 其中一类查询要求 **更新** 数组 `nums` 下标对应的值
2. 另一类查询要求返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含** ）的 nums 元素的 **和** ，其中 `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 用整数数组 `nums` 初始化对象
- `void update(int index, int val)` 将 `nums[index]` 的值 **更新** 为 `val`
- `int sumRange(int left, int right)` 返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含** ）的 nums 元素的 **和** （即，`nums[left] + nums[left + 1], ..., nums[right]`）

![307](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/307.jpg)

**思路**
针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：

1. 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」
2. 多次修改某个数（单点），求区间和：「树状数组」、「线段树」
3. 多次修改某个区间，输出最终结果：「差分」
4. 多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）
5. 多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）

按这样的优先级进行考虑：

1. 简单求区间和，用「前缀和」
2. 多次将某个区间变成同一个数，用「线段树」
3. 其他情况，用「树状数组」

```java
class NumArray {
    /**
     * 树状数组模板代码
     */
    int[] p;
    int lowbit(int x) {
        return x & (-x);
    }
    int query(int x) {
        int ans = 0;
        for (int i = x; i > 0; i -= lowbit(i)) ans += p[i];
        return ans;
    }
    void add(int x, int u) {
        for (int i = x; i <= n; i += lowbit(i)) p[i] += u;
    }
    /** ------------------------------------------------- */
    int n;
    int[] arr;
    public NumArray(int[] nums) {
        arr = nums;
        n = arr.length;
        p = new int[n + 1];
        for (int i = 0; i < n; i ++) add(i + 1, arr[i]);
    }

    public void update(int i, int val) {
        add(i + 1, val - arr[i]);
        arr[i] = val;
    }

    public int sumRange(int l, int r) {
        return query(r + 1) - query(l);
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(i,val);
 * int param_2 = obj.sumRange(left,right);
 */
```

## 字典树

### 100268. 最长公共后缀查询

给你两个字符串数组 `wordsContainer` 和 `wordsQuery` 。

对于每个 `wordsQuery[i]` ，你需要从 `wordsContainer` 中找到一个与 `wordsQuery[i]` 有 **最长公共后缀** 的字符串。如果 `wordsContainer` 中有两个或者更多字符串有最长公共后缀，那么答案为长度 **最短** 的。如果有超过两个字符串有 **相同** 最短长度，那么答案为它们在 `wordsContainer` 中出现 **更早** 的一个。

请你返回一个整数数组 `ans` ，其中 `ans[i]`是 `wordsContainer`中与 `wordsQuery[i]` 有 **最长公共后缀** 字符串的下标。

![100268](https://wwp-study-notes.oss-cn-nanjing.aliyuncs.com/imgs/imgs/leetcode/100268.jpg)

```java
class Solution {
    class TrieNode {
        int minL = Integer.MAX_VALUE;
        int i;
        TrieNode[] children;
        public TrieNode() {
            children = new TrieNode[26];
        }
    }
    public int[] stringIndices(String[] wordsContainer, String[] wordsQuery) {
        TrieNode root = new TrieNode();
        for (int i = 0; i < wordsContainer.length; i ++) {
            char[] cs = wordsContainer[i].toCharArray();
            int l = cs.length;
            TrieNode cur = root;
            if (l < cur.minL) {
                cur.minL = l;
                cur.i = i;
            }
            for (int j = l - 1; j >= 0; j --) {
                int b = cs[j] - 'a';
                if (cur.children[b] == null) {
                    cur.children[b] = new TrieNode();
                }
                cur = cur.children[b];
                if (l < cur.minL) {
                    cur.minL = l;
                    cur.i = i;
                }
            }
        }

        int[] ans = new int[wordsQuery.length];
        for (int i = 0; i < wordsQuery.length; i ++) {
            char[] cs = wordsQuery[i].toCharArray();
            TrieNode cur = root;
            for (int j = cs.length - 1; j >= 0  && cur.children[cs[j] - 'a'] != null; j --) {
                cur = cur.children[cs[j] - 'a'];
            }
            ans[i] = cur.i;
        }
        return ans;
    }
}
```

## 线段树



